# INDEX

---

## 1. 인덱스(Index)란?

- 인덱스는 데이터베이스에서 원하는 데이터를 빠르게 찾기 위해 사용하는 데이터 구조로, 사전의 '찾아보기'와 비슷한 역할을 한다. 
- 조회 결과 자체는 인덱스 유무와 상관없지만, 조회 속도에 큰 영향을 미친다.


### 인덱스의 필요성

- 실무 DB에서는 인덱스 없이는 운영이 불가능에 가까움
- 인덱스는 공간을 더 사용하고, 데이터 수정 작업에는 성능 저하 요인이 될 수 있다.
  - 꼭 필요한 컬럼에만 신중하게 생성해야 한다


### 인덱스의 장단점

#### 장점

- 조회(SELECT) 성능 개선
- 검색 속도 향상 → 전체 시스템 성능 향상

#### 단점

- 인덱스 저장 공간이 필요 (테이블 크기의 약 10%)
- INSERT, UPDATE, DELETE 시 오히려 성능 저하 가능 (정렬 및 페이지 갱신 때문)

---

## 2. 인덱스의 종류

### 클러스터형 인덱스 (Clustered Index)

- 테이블당 1개만 생성 가능
- 기본 키로 지정 시 자동 생성
- 실제 데이터가 인덱스 순서대로 정렬되어 저장됨
- 클러스터 인덱스를 기준으로 테이블 데이터 자체가 정렬됨
- 기본 키 변경 시 인덱스 정렬도 함께 변경됨

### 보조 인덱스 (Secondary / Non-Clustered Index)

- 테이블당 여러 개 생성 가능
- UNIQUE 제약조건 시 자동 생성 또는 CREATE INDEX로 수동 생성
- 실제 데이터와는 별도 구조에 저장됨
- 데이터 자체는 정렬되지 않음 (클러스터형과 차이점)

--- 

## 3. 인덱스 동작 원리

- 클러스터형 인덱스와 보조 인덱스 모두 내부적으로 균형 트리(B-tree) 구조로 구현된다.
- 이 구조에서 데이터가 저장되는 공간은 '노드'라고 하며, 루트 노드, 중간 노드, 리프 노드로 구성된다.
- MySQL에서는 이 노드들을 '페이지'라고 부른다.
- B-tree는 검색 성능이 뛰어난 구조이며, 루트 페이지에서 시작해 검색 대상이 있는 리프 페이지까지 탐색하여 데이터를 추출한다.
  - 이때 몇 개의 페이지를 읽었는지가 성능에 영향을 미친다.
- MySQL에서는 데이터를 페이지 단위(기본 16KB)로 저장한다. 페이지 공간이 부족하면 페이지 분할을 통해 데이터를 분산시킨다.

---

## 4. 페이지 분할

- 데이터 변경 작업(특히 INSERT)이 발생하면 페이지 분할이 일어날 수 있다.
- 페이지 분할이란, 기존 페이지에 공간이 부족할 경우 새로운 페이지를 생성해 데이터를 나누는 작업이다.
- 이 작업이 자주 발생하면 DB 성능에 악영향을 준다.

---

## 5. 클러스터형 인덱스 구조

- 클러스터형 인덱스 페이지는 루트 - (중간) - 리프 페이지 구조로 되어 있다.
- 기본 키 기준으로 실제 데이터가 정렬되며, 리프 노드에는 실제 데이터가 저장된다.
- 검색 시 루트 → 리프까지 탐색하여 빠르게 데이터를 찾을 수 있다.

---

## 6. 보조 인덱스 구조

- 보조 인덱스는 실제 데이터를 정렬하지 않는다.
- 인덱스가 걸린 컬럼 값 기준으로 별도의 인덱스 페이지가 생성되고, 정렬된다.
- 리프 페이지에는 실제 데이터의 위치(주소)가 저장된다. 
- 보조 인덱스가 클러스터형 인덱스와 함께 사용되면, 보조 인덱스의 리프 페이지가 클러스터링된 데이터 페이지를 가리킨다.

---

## 7. 인덱스 사용법

- 인덱스는 데이터베이스 개체로, CREATE와 DELETE 문을 사용해 생성 및 제거할 수 있다.

### 자동으로 생성되는 인덱스

- 클러스터형 인덱스: PK로 지정하거나 UNIQUE + NOT NULL 제약 조건을 설정하면 자동 생성된다.
- 보조 인덱스: UNIQUE 제약 조건을 설정하면 자동 생성된다.

### 인덱스 생성

- 인덱스 생성 SQL 문
```sql
CREATE [UNIQUE] INDEX 인덱스_이름
ON 테이블_이름 (열 이름) [ASC | DESC]
```
- UNIQUE 옵션: 중복이 허용되지 않는 고유 인덱스를 생성한다. 생략하면 중복을 허용한다.
- ASC, DESC 옵션: 인덱스 정렬 방향을 설정한다. DESC는 잘 사용되지 않는다.

### 인덱스 제거

- 인덱스 제거 SQL 문
```sql
DROP INDEX 인덱스_이름 ON 테이블_이름
```
- 기본 키, 고유 키로 자동 생성된 인덱스는 DROP INDEX로 제거할 수 없다.
  - ALTER TABLE 문으로 기본 키나 고유 키를 제거하면 인덱스도 제거된다.
- 보조 인덱스부터 제거하는 것이 좋다.
- 사용하지 않는 인덱스는 과감히 제거하여 메모리 사용을 최적화하는 것이 좋다.

---

## 8. 예제

### 인덱스 생성

- 현재 인덱스는 클러스터형 인덱스 1개, 보조 인덱스 2개이다.

#### 단순 보조 인덱스 생성

```sql
CREATE INDEX idx_member_number ON member (mem_number);
```

#### 고유 보조 인덱스 생성

```sql
CREATE UNIQUE INDEX idx_member_mem_name ON member (mem_name);
```

#### 테이블 분석 및 인덱스 적용

```sql
ANALYZE TABLE member;
```

#### SHOW INDEX로 인덱스 확인

```sql
SHOW INDEX FROM member;
```

### 인덱스를 사용한 조회

#### 단일 행 조회

```sql
SELECT mem_id, mem_name, addr FROM member WHERE mem_name = '에이핑크';
```

#### 범위 검색을 통한 조회

```sql
SELECT * FROM member WHERE mem_number >= 5;
```

### 인덱스 제거

#### 인덱스 제거 SQL 문:

```sql
DROP INDEX idx_member_mem_name ON member;
DROP INDEX idx_member_mem_number ON member;
```

#### 클러스터형 인덱스 제거:

```sql
ALTER TABLE member DROP PRIMARY KEY;
```

---

## 9. 인덱스가 사용되지 않는 경우

### 인덱스 조건 누락 시:

```sql
SELECT * FROM member;  (Full Table Scan 발생)
```

### 전체 테이블 검색이 더 빠른 경우

```sql
SELECT * FROM member WHERE mem_number >= 1;
```

### 인덱스가 사용된 컬럼에 연산이 가해질 경우:

- 인덱스 사용 안됨:
```sql
SELECT mem_name, mem_number FROM member WHERE LENGTH(addr + '1') >= 5;
```
- 인덱스 사용됨:
```sql
SELECT mem_name, mem_number FROM member WHERE LENGTH(addr) >= 5 - 1;
```

---

## 10. 인덱스 성능 비교

1. 인덱스 없이 조회
   - Full Table Scan: 조회 비용이 매우 크다.
2. 인덱스 적용 후 조회:
   - 인덱스 사용: 조회 비용이 크게 줄어든다.
3. 여러 건의 데이터를 조회 시:
   - Index Range Scan 사용 → 조회 비용 증가 → 범위 검색을 할 경우, 조회 비용은 약간 증가하지만 여전히 전체 테이블 스캔보다 효율적이다.
4. 모든 데이터 조회 시:
   - Full Table Scan 발생 → 인덱스가 사용되지 않음 → 조회 비용이 매우 높을 수 있다.
- MySQL의 선택: MySQL은 인덱스 사용과 전체 테이블 조회를 비교하여 더 효율적인 방법을 선택한다.

---

### 참고자료

[INDEX](https://rachel0115.tistory.com/entry/MySQL-%EC%9D%B8%EB%8D%B1%EC%8A%A4-INDEX-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-%EC%83%9D%EC%84%B1-%EC%82%AD%EC%A0%9C-%EC%84%A4%EA%B3%84#%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EB%8F%99%EC%9E%91%20%EC%9B%90%EB%A6%AC-1)