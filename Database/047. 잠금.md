# 잠금

---

## 1. Locking의 목적

- 데이터베이스에서의 Locking(잠금) 메커니즘은 동시성 제어(concurrency control)의 핵심 요소로, 여러 트랜잭션이 동시에 데이터에 접근할 때 발생할 수 있는 충돌을 방지하고 데이터의 일관성과 무결성을 유지하기 위해 사용된다.
- 경합 상태(Race Condition): 여러 트랜잭션이 동시에 같은 데이터를 수정하려 할 때 발생한다. 
- 일관성 문제: 한 트랜잭션이 데이터를 변경하는 동안 다른 트랜잭션이 그 데이터를 읽거나 변경하면 데이터의 일관성이 깨질 수 있다.
- 데이터 무결성: 동시 접근으로 인해 데이터 무결성 제약 조건이 위반될 수 있다.

---

## 2. 잠금의 종류
   
### 공유 잠금(Shared Lock, S Lock)

- 여러 트랜잭션이 동시에 데이터를 읽을 수 있도록 허용한다. 
- 단, 데이터를 수정하려는 트랜잭션은 공유 잠금을 획득한 모든 트랜잭션이 완료될 때까지 대기해야 한다. 

### 배타 잠금(Exclusive Lock, X Lock)

- 데이터를 수정하거나 삭제하려는 트랜잭션에 부여된다. 
- 배타 잠금을 획득한 트랜잭션 외에는 해당 데이터에 대한 다른 잠금을 요청할 수 없으며, 다른 트랜잭션은 데이터를 읽거나 수정할 수 없다.

---

## 3. 잠금의 세부화(Granularity)

### 행 수준 잠금(Row-Level Lock)

- 특정 행에 대해 잠금을 설정한다. 
- 높은 동시성을 제공하지만 잠금 관리 오버헤드가 크다.

### 페이지 수준 잠금(Page-Level Lock) 

- 데이터베이스 페이지 단위로 잠금을 설정한다. 
- 행 수준과 테이블 수준의 중간 정도의 동시성을 제공한다.

### 테이블 수준 잠금(Table-Level Lock)

- 전체 테이블에 대해 잠금을 설정한다. 
- 잠금 관리가 간단하지만 동시성이 낮아질 수 있다.

### 데이터베이스 수준 잠금(Database-Level Lock)

- 전체 데이터베이스에 대해 잠금을 설정한다. 
- 주로 관리 작업 시 사용되며, 동시성이 매우 낮아진다.

---

## 4. 2단계 잠금 프로토콜(Two-Phase Locking, 2PL)
   
- 2단계 잠금 프로토콜은 모든 트랜잭션이 잠금을 획득하는 단계와 잠금을 해제하는 단계의 두 단계를 거치도록 규정한다.
- 2PL은 직렬화를 보장하여 데이터의 일관성을 유지하지만, 교착 상태의 가능성을 증가시킨다.

### 확장 단계(Expanding Phase)

- 트랜잭션이 잠금을 획득하는 단계이다. 
- 이 단계에서는 잠금을 해제할 수 없다.

### 축소 단계(Shrinking Phase)

- 트랜잭션이 잠금을 해제하는 단계하다. 
- 이 단계에서는 더 이상 잠금을 획득할 수 없다.

---

## 5. 교착 상태(Deadlock)
   
- 교착 상태는 두 개 이상의 트랜잭션이 서로가 가진 잠금을 기다리면서 무한 대기 상태에 빠지는 상황을 말한다.

### 해결 방법

- 교착 상태 예방
  - 잠금 획득 순서를 정하거나, 트랜잭션이 필요한 모든 잠금을 한 번에 요청하도록 하여 교착 상태가 발생하지 않도록 합니다.
- 교착 상태 탐지 및 회복
  - 주기적으로 교착 상태를 탐지하고, 교착 상태가 발견되면 하나 이상의 트랜잭션을 강제로 종료하여 교착 상태를 해소합니다. 
- 타임아웃 설정
  - 트랜잭션이 일정 시간 내에 필요한 잠금을 획득하지 못하면 트랜잭션을 롤백하여 교착 상태를 방지합니다.

---

## 6. 격리 수준(Isolation Levels)과 잠금
   
- 데이터베이스는 여러 격리 수준을 제공하여 트랜잭션 간의 상호 작용을 제어한다. 
- 각 격리 수준은 잠금 전략에 영향을 미친다.
- 격리 수준이 높을수록 데이터 일관성은 높아지지만, 동시성은 낮아지고 잠금 오버헤드가 증가할 수 있습니다.

### Read Uncommitted

- 가장 낮은 격리 수준으로 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있다. 
- 잠금이 거의 없거나 공유 잠금만 사용한다.

### Read Committed

- 트랜잭션이 커밋된 데이터만을 읽을 수 있다. 
- 공유 잠금을 사용하여 데이터 읽기 시 잠금을 설정하고, 읽기 후 즉시 해제된다.

### Repeatable Read

- 트랜잭션이 시작된 시점의 데이터를 계속 읽을 수 있다. 
- 데이터를 읽을 때 공유 잠금을 유지하여 다른 트랜잭션이 데이터를 수정하지 못하도록 합니다.

### Serializable

- 가장 높은 격리 수준으로, 트랜잭션들이 완전히 직렬화된 것처럼 동작하도록 보장한다. 
- 범위 잠금과 같은 추가적인 잠금 전략을 사용하여 팬텀 읽기를 방지한다.

---

## 7. 낙관적 잠금과 비관적 잠금
   
### 비관적 잠금(Pessimistic Locking)

- 트랜잭션이 데이터를 수정하기 전에 반드시 잠금을 획득하여 다른 트랜잭션의 접근을 차단한다. 
- 주로 데이터 충돌 가능성이 높을 때 사용된다.

### 낙관적 잠금(Optimistic Locking)

- 트랜잭션이 데이터를 수정할 때 충돌이 발생하지 않을 것이라고 가정하고 잠금을 사용하지 않는다. 
- 대신, 데이터 수정 시점에 충돌 여부를 검사하여 문제가 있을 경우 트랜잭션을 롤백하거나 재시도한다. 
- 주로 데이터 충돌 가능성이 낮을 때 사용된다.

---

## 8. 잠금 관리의 최적화

- 잠금 범위 최소화
  - 필요한 최소한의 데이터에 대해서만 잠금을 설정하여 동시성을 높인다. 
- 트랜잭션 크기 축소
  - 트랜잭션이 빠르게 완료되도록 하여 잠금 유지 시간을 줄인다. 
- 적절한 격리 수준 선택
  - 응용 프로그램의 요구사항에 맞는 적절한 격리 수준을 선택하여 성능과 일관성 간의 균형을 맞춘다. 
- 인덱스 최적화
  - 효율적인 인덱스를 사용하여 잠금 범위를 줄이고 쿼리 성능을 향상시킨다.

---

### 참고자료

[잠금](https://velog.io/@ouk/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90%EC%84%9C%EC%9D%98-Locking-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)