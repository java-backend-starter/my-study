# 트랜잭션

---

## 트랜잭션

### 정의

- 트랜잭션은 DB의 상태를 변경시키는 작업의 단위다.
- 쉽게 말해, 한꺼번에 수행되어야 할 연산을 모아놓은 것이다.
- 연산들을 모두 처리하지 못한 경우에는 원 상태로 복구된다. 즉, 작업의 일부만 적용되는 현상이 발생하지 않는다.
- 이를 통해 트랜잭션은 작업의 완전성을 보장해준다.
- 사용자의 입장에서는 작업의 논리적 단위이고, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

### 트랜잭션의 4가지 특징: ACID

- Atomicity (원자성)
  - 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다. (All or Nothing)
- Consistency (일관성)
  - 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다. 
  - 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같아야 하며, DB의 제약조건을 위배하는 작업을 트랜잭션 과정에서 수행할 수 없다.
  - 예: 송금 시 금액의 데이터 타입을 정수형(integer)에서 문자열(string)로 변경할 수 없음.
- Isolation (독립성)
  - 둘 이상의 트랜잭션이 동시에 병행 실행될 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
- Durability (지속성)
  - 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 반영된다.

### 트랜잭션의 연산

- COMMIT 연산
  - 트랜잭션이 성공적으로 수행되었음을 선언하는 연산이다.
  - COMMIT 연산의 실행을 통해 트랜잭션의 수행이 성공적으로 완료되었음을 선언하고, 그 결과를 최종 DB에 반영한다.
- ROLLBACK 연산
  - 트랜잭션 수행이 실패했음을 선언하고 작업을 취소하는 연산이다. 
  - 트랜잭션 도중 일부 연산이 처리되지 못한 경우 ROLLBACK 연산을 실행하여 트랜잭션 수행 전과 일관된 상태로 DB를 되돌린다.

---

## 2. 트랜잭션 사용 시 주의할 점

- 트랜잭션은 꼭 필요한 최소한의 코드에만 적용하는 것이 좋다.
  - 즉, 트랜잭션의 범위를 최소화해야 한다. 
- 일반적으로 DB 커넥션은 개수가 제한적이다. 
  - 각 단위 프로그램이 커넥션을 소유하는 시간이 길어지면, 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 
  - 이로 인해 어느 순간 각 단위 프로그램이 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다.

---

## 3. 병행제어

- 여러 개의 트랜잭션이 실행될 때, 트랜잭션들이 DB의 일관성을 파괴하지 않고 다른 트랜잭션에 영향을 주지 않으면서 트랜잭션을 제어하는 것을 의미한다.

### 병행 실행 시 발생 가능한 문제들

- 분실된 갱신
  - 두 개의 트랜잭션이 같은 데이터에 대해 동시에 갱신 작업을 하면, 하나의 갱신 작업이 분실되는 경우.
- 모순성
  - 한 트랜잭션이 갱신 작업을 하고 있는 상태에서 다른 트랜잭션이 같은 작업 구역에 침범하여 작업을 진행하면, DB의 일관성을 해치는 경우.
- 연쇄복귀
  - 같은 자원을 사용하는 두 개의 트랜잭션 중 하나가 성공적으로 일을 수행해도 다른 트랜잭션이 실패하면 두 트랜잭션 모두가 복귀되는 현상.
- 비완료 의존성 
  - 한 트랜잭션이 수행 도중 실패할 때, 이 트랜잭션이 회복되기 전에 다른 트랜잭션이 수행 결과를 참조하는 현상.

### 병행제어 기법

#### 로킹(Locking)

- 트랜잭션이 데이터에 접근할 때 로킹을 수행하며, 한 트랜잭션만이 로킹 해제를 할 수 있다.
- 로킹 단위가 크면 관리 용이하지만 동시성 수준이 감소하고, 작으면 동시성 수준이 증가하지만 관리가 어려워진다.
- 2단계 로킹 규약(Two-Phase Locking Protocol)
  - Lock과 Unlock이 동시에 이루어지면 일관성이 보장되지 않으므로, Lock만 가능한 단계와 Unlock만 가능한 단계를 구분하여 직렬가능성을 보장한다.
  - 확장단계: 트랜잭션이 Lock 가능, Unlock 불가능
  - 축소단계: 트랜잭션이 Unlock 가능, Lock 불가능
  - 예시: T1: write(A) read(B), T2: read(B) write(A) ⇒ dead lock 발생
- 로킹의 종류
    - S-lock (공유잠금): 공유잠금을 설정한 트랜잭션은 데이터 항목에 대해 읽기만 가능.
    - X-lock (배타잠금): 배타잠금을 설정한 트랜잭션은 읽기와 쓰기 모두 가능.
- 타임 스탬프(Time Stamp)
  - 데이터에 접근하는 시간을 미리 정하여, 정해진 시간 순서대로 데이터에 접근한다. 
  - 교착 상태가 발생하지 않지만 연쇄 복귀를 초래할 수 있다.
- 낙관적 병행제어(Optimistic Concurrency Control)
  - 트랜잭션 수행 동안 검사하지 않고, 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증된다.
- 다중 버전 병행제어(Multi-version Concurrency Control)
  - 여러 버전의 값을 유지하며 조회 성능을 유지하고 충돌 문제는 복귀 처리로 해결하지만 연쇄 복귀를 초래할 수 있다.

---

## 4. 교착상태 (Deadlock)

- 두 개 이상의 트랜잭션이 특정 자원의 잠금을 획득한 채 다른 트랜잭션이 소유한 잠금을 요구해, 아무리 기다려도 상황이 바뀌지 않는 상태를 의미한다.

### 교착상태의 예시 (MySQL)

- MySQL에서는 트랜잭션이 갱신 연산(Insert, Update, Delete)을 실행할 때 잠금을 획득한다.
- 예시:
    - T1이 테이블 B의 첫 번째 행을 잠그고, T2가 테이블 A의 첫 번째 행을 잠그면, 서로의 행에 대해 잠금을 요청하면서 교착상태가 발생한다.
    - `ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction`이 발생한다.

### 교착상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 COMMIT 한다.
- 정해진 순서로 테이블에 접근한다.
    - 예: T1이 테이블B → A 순으로 접근하고, T2는 테이블A → B 순으로 접근.
- 읽기 잠금 획득(SELECT ~ FOR UPDATE)을 피한다.
- 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉬우므로, 테이블 단위로 잠금을 획득해 갱신을 직렬화한다.

---

### 참고자료

[트랜잭션](https://velog.io/@shasha/Database-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%95%EB%A6%AC)