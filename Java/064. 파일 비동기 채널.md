# 파일 비동기 채널

---

## 1. 개요

- FileChannel의 read()와 write() 메소드는 호출 시 블로킹된다. 
  - UI 스레드나 이벤트 처리 스레드에서 호출하면 UI 갱신이나 이벤트 처리에 지장이 생긴다. 
  - 다수의 파일이나 대용량 파일을 처리할 경우 스레드 수가 늘어나 문제될 수 있다. 
- 위의 문제를 해결하기 위해 자바 NIO는 AsynchronousFileChannel을 제공한다.
  - read()와 write() 호출 시 즉시 리턴
  - 실제 입출력 작업은 스레드풀의 작업 스레드가 수행
  - 완료 시 콜백(callback) 메소드 자동 호출

---

## 2. AsynchronousFileChannel 생성과 종료

###  기본 생성

```java
AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
    Path file,
    OpenOption... options
);
```
- 내부적으로 기본 스레드풀 사용
- 기본 스레드풀의 최대 스레드 수는 지정 불가

### 스레드풀 지정 생성

```java
ExecutorService executorService = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
    Paths.get("C:/Temp/file.txt"),
    EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE),
    executorService
);
```
- executorService: 사용자 지정 스레드풀
- EnumSet.of(): 열거 상수를 Set으로 묶음
- Runtime.getRuntime().availableProcessors(): CPU 코어 수

### 종료

```java
fileChannel.close();
```
- 사용 후 반드시 close() 호출 필요

---

## 3. 파일 읽기와 쓰기 (AsynchronousFileChannel)

### 주요 메소드

```java
read(ByteBuffer dst, long position, A attachment, CompletionHandler<Integer, A> handler);
write(ByteBuffer src, long position, A attachment, CompletionHandler<Integer, A> handler);
```
- dst/src: 읽기/쓰기용 ByteBuffer
- position: 파일 내 시작 위치 (0부터 시작 가능)
- attachment: 콜백 전달용 객체 (null 가능)
- handler: 비동기 작업 완료/실패 시 호출되는 CompletionHandler

### CompletionHandler 구조

```java
new CompletionHandler<Integer, A>() {
    @Override
    public void completed(Integer result, A attachment) { ... }

    @Override
    public void failed(Throwable exc, A attachment) { ... }
}
```
- completed(Integer result, A attachment): 정상 완료 시 호출 (result = 처리된 바이트 수)
- failed(Throwable exc, A attachment): 실패 시 호출 (exc = 발생한 예외)
- 콜백 메소드는 호출 스레드가 아닌 스레드풀의 스레드에서 실행 → UI 작업 시 Platform.runLater() 필요 (JavaFX)

### 비동기 파일 쓰기 예제

```java
ExecutorService executorService = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

for (int i = 0; i < 10; i++) {
    Path path = Paths.get("C:/Temp/file" + i + ".txt");
    Files.createDirectories(path.getParent());

    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
        path,
        EnumSet.of(StandardOpenOption.CREATE, StandardOpenOption.WRITE),
        executorService
    );

    ByteBuffer byteBuffer = Charset.defaultCharset().encode("안녕하세요");

    class Attachment {
        Path path;
        AsynchronousFileChannel fileChannel;
    }

    Attachment attachment = new Attachment();
    attachment.path = path;
    attachment.fileChannel = fileChannel;

    CompletionHandler<Integer, Attachment> handler = new CompletionHandler<>() {
        @Override
        public void completed(Integer result, Attachment attachment) {
            System.out.println(attachment.path.getFileName() + " : " + result + " bytes written : " + Thread.currentThread().getName());
            try { attachment.fileChannel.close(); } catch (IOException e) { e.printStackTrace(); }
        }

        @Override
        public void failed(Throwable exc, Attachment attachment) {
            exc.printStackTrace();
            try { attachment.fileChannel.close(); } catch (IOException e) { e.printStackTrace(); }
        }
    };

    fileChannel.write(byteBuffer, 0, attachment, handler);
}

executorService.shutdown();
```
> 주의: write() 호출 직후 채널을 닫으면 안 되며, completed()와 failed()에서 닫아야 함.

### 비동기 파일 읽기 예제

```java
ExecutorService executorService = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

for (int i = 0; i < 10; i++) {
    Path path = Paths.get("C:/Temp/file" + i + ".txt");

    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
        path,
        EnumSet.of(StandardOpenOption.READ),
        executorService
    );

    ByteBuffer byteBuffer = ByteBuffer.allocate((int) fileChannel.size());

    class Attachment {
        Path path;
        AsynchronousFileChannel fileChannel;
        ByteBuffer byteBuffer;
    }

    Attachment attachment = new Attachment();
    attachment.path = path;
    attachment.fileChannel = fileChannel;
    attachment.byteBuffer = byteBuffer;

    CompletionHandler<Integer, Attachment> handler = new CompletionHandler<>() {
        @Override
        public void completed(Integer result, Attachment attachment) {
            attachment.byteBuffer.flip();
            String data = Charset.defaultCharset().decode(attachment.byteBuffer).toString();
            System.out.println(attachment.path.getFileName() + ": " + data + " : " + Thread.currentThread().getName());
            try { attachment.fileChannel.close(); } catch (IOException e) { e.printStackTrace(); }
        }

        @Override
        public void failed(Throwable exc, Attachment attachment) {
            exc.printStackTrace();
            try { attachment.fileChannel.close(); } catch (IOException e) { e.printStackTrace(); }
        }
    };

    fileChannel.read(byteBuffer, 0, attachment, handler);
}

executorService.shutdown();
```
> 주의: read() 호출 직후 채널을 닫으면 안 되며, completed()와 failed()에서 닫아야 함.

---

### 참고자료

[이것이 자바다](https://search.shopping.naver.com/book/catalog/32473359191?query=%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%B0%94%EB%8B%A4&NaPm=ct%3Dm7ne3c9k%7Cci%3D6356ea398110d474e244102192a893d910277fb2%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Da51fed5127109d9f5a3bd6af6be4725cd7500518)