# 클래스와 객체

---

## 1. 클래스, 객체, 인스턴스

* 클래스(Class)
  * 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도
  * 클래스는 객체가 가지는 속성(필드)과 동작(메서드)으로 이루어져 있다.
  * 필드와 메서드는 반드시 존재할 필요는 없기에 생략될 수 있다.
  * JVM 메모리에서 클래스 영역에 로드된다.
* 객체(Object)
  * 고유의 속성과 동작을 가지고 있는 물리적 또는 추상적인 대상
  * 객체는 다른 것들과 식별이 가능하다.
  * 객체는 객체 간의 메소드 호출을 통해 상호작용을 하며 매개값과 리턴값을 통해 데이터를 주고받는다.
* 인스턴스(Instance)
  * 클래스를 통해 생성된 객체들로 객체를 클래스의 인스턴스라고도 한다.
  * 인스턴스는 JVM의 힙 영역에 생성된다.

---

## 2. 클래스의 구성 맴버

### 필드(Field)

* 객체의 고유 데이터, 부품, 상태 데이터를 저장하는 공간
* 필드는 클래스 중괄호 {} 내부 어디서든 선언할 수 있다.
  * 생성자나 메소드 내부에서는 선언할 수 없다. 
  * 생성자나 매소드 내부에서 선언된 변수는 로컬 변수로 취급된다.
  * 필드 선언 형식
    * 타입 필드명 [= 초기값]; 형태
    * 타입에는 기본 타입과 참조 타입이 올 수 있다.
  * 초기값을 지정하지 않으면 자동으로 기본값이 할당된다.
* 필드의 기본 초기값
  * 정수 타입(byte, short, int, long): 0
  * 실수 타입(float, double): 0.0
  * boolean 타입: false
  * char 타입: '\u0000' (빈 공백)
  * 배열, 클래스(String 포함), 인터페이스: null
* 필드 사용
  * 필드 값을 읽거나 변경하려면 생성자나 메소드 내부에서 필드 이름을 사용
  * 클래스 외부에서 필드를 사용하려면 객체를 생성한 후 객체명.필드명 형식으로 접근
  * 필드는 객체에 속해 있으므로 객체가 존재해야만 사용 가능하다.
* 필드 자동 초기화 확인
  * 객체를 생성하면 선언된 필드들은 위에서 언급한 기본값으로 자동 초기화된다.

---

### 생성자

* 생성자의 역할
  * new 연산자와 함께 사용되어 객체를 생성하고 초기화함.
  * 필드를 초기화하거나 메소드를 호출하여 객체를 사용할 준비를 함.
  * 생성자를 실행하지 않으면 객체를 만들 수 없음.
  * 생성이 성공하면 객체가 메모리(heap)에 생성되고, 주소가 반환됨.
* 기본 생성자 (Default Constructor)
  * 모든 클래스는 하나 이상의 생성자를 가짐.
  * 생성자를 명시적으로 선언하지 않으면, 컴파일러가 자동으로 기본 생성자를 추가함.
  * 클래스에 명시적 생성자가 있으면 기본 생성자는 자동 추가되지 않음.
* 명시적 생성자 선언
  * 생성자는 메서드와 유사하지만, 리턴 타입이 없고 클래스 이름과 동일함.
  * 객체를 다양한 방식으로 초기화하기 위해 명시적으로 생성자를 선언할 수 있음.
  * 매개변수를 사용하여 객체 생성 시 외부 값을 전달할 수 있음.
  * 명시적 생성자가 있는 경우에 기본 생성자를 호출할 수 없으며, 반드시 명시된 생성자를 사용해야 함.
* 필드 초기화
  * 객체 생성 시 필드는 기본값으로 자동 설정됨.
  * 다른 값으로 초기화하는 법 
    * 필드 선언 시 값을 준다.
    * 생성자에서 값을 지정한다.
  * 필드 선언 시 값을 지정하면 모든 객체가 동일한 값을 가짐.
  * 외부 입력 값으로 초기화하려면 생성자에서 설정해야 함. 
* 생성자 오버로딩 (Overloading)
  * 객체 초기화를 다양하게 하기 위해 매개변수를 다르게 하여 여러 개의 생성자를 선언 가능
  * 매개변수 타입, 개수, 순서가 달라야 오버로딩이 성립됨.
  * 호출되는 생성자는 매개값의 타입과 수에 따라 결정됨.
* 다른 생성자 호출 (this())
  * 중복 코드 방지를 위해 하나의 생성자가 다른 생성자를 호출 가능.
  * this()를 사용하여 같은 클래스 내 다른 생성자를 호출하며, 반드시 첫 줄에서 사용해야 함.
  * 호출된 생성자 실행이 끝난 후 원래 생성자로 돌아와서 나머지 코드 실행.

---

### 메소드

* 메소드
  * 객체의 동작을 정의하는 코드 블록 {}
  * 필드를 읽고 수정하며, 다른 객체를 생성하거나 데이터 전달 역할 수행
  * 매개값을 받을 수도 있고, 실행 후 값을 리턴할 수도 있음
* 메소드 선언
  * 구성 요소: 리턴 타입, 메소드 이름, 매개변수 선언, 실행 블록
  * 리턴 타입
    * void: 리턴값 없음 (예: powerOn())
    * 특정 데이터 타입: 해당 타입의 값 리턴 (예: double divide(int x, int y))
* 메소드 호출
  * 리턴값이 없는 경우: powerOn();
  * 리턴값이 있는 경우: double result = divide(10, 20);
  * 리턴값이 필요 없을 경우 변수 없이 호출 가능(이 경우에는 메소드 실행이 중요한 경우)
* 메소드 이름 규칙
  * 숫자로 시작 X, 특수문자 사용 X ($, _ 제외)
  * 소문자로 시작, 여러 단어는 뒤 단어 첫 글자 대문자 (camelCase)
  * 기능을 쉽게 알 수 있도록 의미 있는 이름 사용
* 매개변수 선언
  * 메소드 실행에 필요한 데이터를 외부에서 전달받는 변수
  * 개수가 정해져 있지 않을 경우 
    * 배열(int[] numbers) 또는 가변 인자(int... numbers) 사용
* 리턴 (return) 문 
  * 리턴값이 있는 메소드
    * 반드시 return문 사용
    * 리턴 타입과 일치하거나 변환 가능한 타입만 리턴 가능
  * 리턴값이 없는 메소드 (void)
    * return; 사용 시 메소드 즉시 종료 가능
* 메소드 호출 방식
  * 객체 내부에서 호출 
    * 같은 클래스 내에서 단순히 메소드 이름으로 호출 
    * 리턴값이 있는 경우 변수에 저장 가능
  * 객체 외부에서 호출 
    * 객체 생성 후 참조변수.메소드이름(매개값) 형태로 호출 
  * 메소드 실행 흐름 
    * 호출된 메소드가 다른 메소드를 호출할 수도 있음 
    * 실행 흐름을 파악하려면 호출 관계를 추적해야 함
* 메소드 오버로딩
  * 같은 이름의 메소드를 매개변수의 타입, 개수, 순서를 다르게 하여 여러 개 선언하는 것
  * 목적
    * 다양한 매개값을 처리할 수 있도록 하기 위해 사용됨.
  * JVM 동작 방식
    * 메소드 호출 시 매개변수의 타입을 기준으로 적절한 메소드 선택 
    * 일치하는 타입이 없으면 자동 타입 변환 가능 여부를 검사 후 선택
  * 주의할 점 
    * 매개변수 이름만 변경하는 것은 오버로딩이 아님 
    * 리턴 타입만 다르고 매개변수가 같으면 오버로딩이 아님 → 컴파일 오류 발생

---

### 참고 자료

[이것이 자바다](https://search.shopping.naver.com/book/catalog/32473359191?query=%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%B0%94%EB%8B%A4&NaPm=ct%3Dm7ne3c9k%7Cci%3D6356ea398110d474e244102192a893d910277fb2%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Da51fed5127109d9f5a3bd6af6be4725cd7500518)

[클래스와 객체, 인스턴스의 차이](https://velog.io/@dongvelop/Java-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4)