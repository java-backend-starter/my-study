# TCP 블로킹 채널

---

## 1. 개요

- NIO를 이용해 TCP 서버/클라이언트 애플리케이션을 개발할 때, 블로킹, 넌블로킹, 비동기 구현 방식 중 하나를 선택해야 한다. 
- 이 결정에 따라 구현이 달라지므로 성능과 효율성을 고려한 최적의 네트워크 애플리케이션을 개발할 수 있다.

### UDP 채널

- NIO에서 UDP 통신은 `DatagramChannel` 클래스를 사용한다.
- TCP와 달리 비연결형(Connectionless) 통신을 제공한다.
    - 연결을 미리 설정하지 않고, 메시지 단위로 송수신한다.
    - 순서와 신뢰성 보장은 안한다.
- TCP처럼 블로킹과 넌블로킹 모드를 지원한다.

---

## 2. 서버소켓 채널과 소켓 채널의 용도

- NIO에서 TCP 네트워크 통신을 위해 사용하는 채널은 java.nio.channels.ServerSocketChannel과 java.nio.channels.SocketChannel이다. 
- 두 채널은 IO의 ServerSocket과 Socket에 대응되며, ServerSocketChannel은 클라이언트의 연결 요청을 수락하고, SocketChannel은 통신용 채널을 생성한다. 
- 이 채널들은 블로킹과 넌블로킹 방식을 모두 지원한다.

### 서버소켓 채널 생성과 연결 수락

- 서버를 개발하려면 ServerSocketChannel 객체를 생성해야 한다. 
- ServerSocketChannel은 open() 메소드로 생성하고, 블로킹 방식으로 동작하게 하려면 configureBlocking(true) 메소드를 호출한다. 
- 기본적으로 블로킹 방식이지만, 명시적으로 설정하는 이유는 넌블로킹 방식과 구분하기 위해서이다. 
- 포트에 바인딩하려면 bind() 메소드를 호출하고, InetSocketAddress 객체를 매개값으로 주면 된다.

```java
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.configureBlocking(true);
serverSocketChannel.bind(new InetSocketAddress(5001));
```

- ServerSocketChannel은 클라이언트의 연결 요청을 기다리기 위해 accept() 메소드를 호출한다. 
- accept()는 클라이언트가 연결 요청을 할 때까지 블로킹되므로 UI나 이벤트 처리 스레드에서 호출하지 않도록 한다. 
- 연결이 이루어지면 accept()는 SocketChannel을 반환한다.

```java
SocketChannel socketChannel = serverSocketChannel.accept();
```

- 연결된 클라이언트의 IP와 포트 정보를 얻고 싶다면 SocketChannel의 getRemoteAddress() 메소드를 사용한다.

```java
InetSocketAddress socketAddress = (InetSocketAddress) socketChannel.getRemoteAddress();
```

```java 
serverSocketChannel.close();
```

### InetSocketAddress에서 IP와 포트 정보를 얻는 메소드

|메소드|	설명|
|:---:|:---:|
|getHostName()|	클라이언트 IP 리턴|
|getPort()|	클라이언트 포트 번호 리턴|
|toString()|	"IP:포트번호" 형태 문자열 리턴|

- ServerSocketChannel을 더 이상 사용하지 않으려면 close() 메소드를 호출하여 포트를 언바인딩해야 다른 프로그램에서 재사용할 수 있다.


### 예제: 다중 클라이언트 연결 수락

```java
public class ServerExample {
    public static void main(String[] args) {
        ServerSocketChannel serverSocketChannel = null;
        try {
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(true);
            serverSocketChannel.bind(new InetSocketAddress(5001));
            while(true) {
                System.out.println("[연결 기다림]");
                SocketChannel socketChannel = serverSocketChannel.accept();
                InetSocketAddress isa = (InetSocketAddress) socketChannel.getRemoteAddress();
                System.out.println("[연결 수락함] " + isa.getHostName());
            }
        } catch(Exception e) {
            ...
        }
        if(serverSocketChannel.isOpen()) {   
            try {
                serverSocketChannel.close();
            } catch (IOException e1) {
                ...
            }
        }
    }
}
```

---

## 3. 소켓 채널 생성과 연결 요청

- 클라이언트가 서버에 연결 요청을 할 때는 SocketChannel을 사용한다. 
- SocketChannel은 open() 메소드로 생성하고, 블로킹 방식으로 동작하려면 configureBlocking(true) 메소드를 호출한다. 
- 서버 연결은 connect() 메소드를 사용하고, InetSocketAddress 객체를 매개값으로 제공한다.

```java
SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(true);
socketChannel.connect(new InetSocketAddress("localhost", 5001));
```
- connect() 메소드는 서버와 연결될 때까지 블로킹되므로 UI나 이벤트를 처리하는 스레드에서 호출하지 않도록 한다. 연결이 완료되면 SocketChannel을 종료할 때 close() 메소드를 호출하면 된다.

``` java
socketChannel.close();
```

### 예제: 서버에 연결 요청

```java
public class ClientExample {
    public static void main(String[] args) {
        SocketChannel socketChannel = null;
        try {
            socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(true);
            System.out.println("[연결 요청]");
            socketChannel.connect(new InetSocketAddress("localhost", 5001));
            System.out.println("[연결 성공]");
        } catch(Exception e) {
            ...
        }
        if(socketChannel.isOpen()) {
            try {
                socketChannel.close();
            } catch (IOException e1) {
                ...
            }
        }
    }
}
```
- 실행 결과 
  - 서버 애플리케이션을 먼저 실행하고, 클라이언트 애플리케이션을 실행하면 연결이 수립된다.

---

## 4. 소켓 채널 데이터 통신

- 클라이언트가 서버에 연결 요청(connect())을 하고, 서버가 이를 수락(accept())하면, 양쪽 SocketChannel 객체의 read()와 write() 메소드를 이용하여 데이터 통신을 할 수 있다. 
- 이 메소드들은 모두 버퍼를 이용하므로, 데이터를 읽고 쓰는 작업은 반드시 버퍼를 사용해야 한다.

### 데이터 전송 (클라이언트 → 서버)

- SocketChannel의 write() 메소드를 사용하여 데이터를 보내는 예제:
```java
Charset charset = Charset.forName("UTF-8");
ByteBuffer byteBuffer = charset.encode("Hello Server");
socketChannel.write(byteBuffer);
```

### 데이터 수신 (클라이언트 ← 서버)

- SocketChannel의 read() 메소드를 사용하여 데이터를 받는 예제:
```java
ByteBuffer byteBuffer = ByteBuffer.allocate(100);
int byteCount = socketChannel.read(byteBuffer);
byteBuffer.flip();
Charset charset = Charset.forName("UTF-8");
String message = charset.decode(byteBuffer).toString();
```

### 예제: 데이터 주고받기 (클라이언트)

- 클라이언트가 "Hello Server" 메시지를 보내고, 서버는 "Hello Client"를 보낸 후 클라이언트는 이를 수신한다.
```java
public class ClientExample {
    public static void main(String[] args) {
        SocketChannel socketChannel = null;
        try {
            socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(true);
            System.out.println("[연결 요청]");
            socketChannel.connect(new InetSocketAddress("localhost", 5001));
            System.out.println("[연결 성공]");

            ByteBuffer byteBuffer = null;
            Charset charset = Charset.forName("UTF-8");

            byteBuffer = charset.encode("Hello Server");
            socketChannel.write(byteBuffer);
            System.out.println("[데이터 보내기 성공]");

            byteBuffer = ByteBuffer.allocate(100);
            int byteCount = socketChannel.read(byteBuffer);
            byteBuffer.flip();
            String message = charset.decode(byteBuffer).toString();
            System.out.println("[데이터 받기 성공]: " + message);
        } catch (Exception e) {
            // 예외 처리
        }

        if (socketChannel.isOpen()) {
            try {
                socketChannel.close();
            } catch (IOException e1) {
                // 예외 처리
            }
        }
    }
}
```

### 예제: 데이터 주고받기 (서버)

- 서버는 클라이언트로부터 메시지를 받으면, 응답으로 "Hello Client" 메시지를 보낸다.
```java
public class ServerExample {
    public static void main(String[] args) {
        ServerSocketChannel serverSocketChannel = null;
        try {
            serverSocketChannel = ServerSocketChannel.open();
            serverSocketChannel.configureBlocking(true);
            serverSocketChannel.bind(new InetSocketAddress(5001));
            while (true) {
                System.out.println("[연결 기다림]");
                SocketChannel socketChannel = serverSocketChannel.accept();
                InetSocketAddress isa = (InetSocketAddress) socketChannel.getRemoteAddress();
                System.out.println("[연결 수락함] " + isa.getHostName());

                ByteBuffer byteBuffer = null;
                Charset charset = Charset.forName("UTF-8");

                byteBuffer = ByteBuffer.allocate(100);
                int byteCount = socketChannel.read(byteBuffer);
                byteBuffer.flip();
                String message = charset.decode(byteBuffer).toString();
                System.out.println("[데이터 받기 성공]: " + message);

                byteBuffer = charset.encode("Hello Client");
                socketChannel.write(byteBuffer);
                System.out.println("[데이터 보내기 성공]");
            }
        } catch (Exception e) {
            // 예외 처리
        }

        if (serverSocketChannel.isOpen()) {
            try {
                serverSocketChannel.close();
            } catch (IOException e1) {
                // 예외 처리
            }
        }
    }
}
```

### 블로킹 해제 및 예외 처리

- read() 메소드는 상대방이 데이터를 보내기 전까지 블로킹되며, 블로킹이 해제되면 다음 세 가지 경우로 리턴된다:
  - 블로킹 해제되는 경우 : 리턴값
  - 상대방이 데이터를 보냈을 때읽은 바이트 수상대방이 정상적으로 SocketChannel의 close()를 호출했을 때 : -1
  - 상대방이 비정상적으로 종료했을 때 (예외 발생) : IOException 발생
- 상대방이 SocketChannel의 close()를 호출하여 정상적으로 연결을 종료했거나 비정상적으로 종료되면 예외를 처리해야 하며, 이쪽에서도 close() 메소드를 호출하여 연결을 종료해야 한다.

#### 예외 처리 예시

```java
try {
    int byteCount = socketChannel.read(byteBuffer);

    if (byteCount == -1) {
        throw new IOException();  // 강제로 IOException 발생시킴
    }
} catch (Exception e) {
    try {
        socketChannel.close();
    } catch (Exception e2) {
        // 예외 처리
    }
}
```
#### 실행 결과

- 서버 애플리케이션(ServerExample)을 먼저 실행하고, 클라이언트 애플리케이션(ClientExample)을 실행하면 다음과 같은 결과가 나온다:
  - 클라이언트는 "Hello Server" 메시지를 보낸다. 
  - 서버는 해당 메시지를 수신하고 "Hello Client"를 응답으로 클라이언트에게 보낸다. 
  - 클라이언트는 서버로부터 받은 "Hello Client" 메시지를 출력한다.

---

## 5. 스레드 병렬 처리

### 블로킹의 문제

- `read()`와 `write()`는 데이터 입출력 완료 전까지 스레드를 블로킹시킨다. 
- 메인 스레드가 직접 입출력을 처리하면 그동안 다른 작업을 전혀 수행할 수 없다. 
  - 서버는 계속해서 새로운 클라이언트 연결을 수락해야 하는데, 블로킹되면 정지 상태가 된다. 
  - 한 클라이언트 입출력 중에는 다른 클라이언트 요청을 처리할 수도 없다.

### 해결책: 스레드 병렬 처리

- 클라이언트 연결(채널) 하나당 스레드 하나를 할당**해 독립적으로 입출력을 수행한다. 
- 이렇게 하면 여러 클라이언트가 동시에 통신할 수 있다.

### 문제점: 스레드 폭증

- 수천 명의 클라이언트가 연결되면 수천 개의 스레드가 생성된다.
- 스레드 수가 많아질수록 문맥 전환 비용 증가 → CPU 부하 → 서버 성능 급락 및 다운 가능.

### 개선책: 스레드풀(Thread Pool)

- 스레드 수를 제한하고, 작업은 큐(Queue)에 쌓는다.
- 갑작스러운 접속 폭증 시에도 스레드 수는 일정하게 유지된다.
- 단, 대기 작업이 늘어나므로 응답 지연이 발생할 수 있다.
- 서버의 하드웨어 성능에 맞게 적절한 스레드 수를 설정해야 한다.

---

## 6. 블로킹과 인터럽트

### 1. 기존 IO의 한계

- `Socket` 기반의 입출력(`read()`, `write()`)이 블로킹된 상태에서 다른 스레드가 `interrupt()`를 호출해도 블로킹이 해제되지 않는다.
- 해결 방법
  - `socket.close()`를 호출해 `SocketException`을 강제로 발생시켜 블로킹을 해제한다.

### 2. NIO의 장점

- `SocketChannel`은 다르다. 
  - 블로킹 상태일 때 다른 스레드가 `interrupt()` 호출 → `ClosedByInterruptException` 발생
  - 동시에 `SocketChannel`이 닫히면서 즉시 블로킹 해제
  - 또는 `close()`를 직접 호출하면 `AsynchronousCloseException` 발생하면서 해제된다.

### 3. 예제 코드 개요

```java
Thread thread = null;

public void receive() {
    thread = new Thread() {
        @Override
        public void run() {
            try {
                int byteCount = socketChannel.read(byteBuffer);
                // 데이터 읽기 처리
            } catch (Exception e) {
                // ClosedByInterruptException 발생 시
                socketChannel.close();
            }
        }
    };
    thread.start();
}

public void stop() {
    thread.interrupt();  // 다른 스레드에서 호출 → 읽기 중단 유도
}
```

---

### 참고자료

[이것이 자바다](https://search.shopping.naver.com/book/catalog/32473359191?query=%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%B0%94%EB%8B%A4&NaPm=ct%3Dm7ne3c9k%7Cci%3D6356ea398110d474e244102192a893d910277fb2%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Da51fed5127109d9f5a3bd6af6be4725cd7500518)