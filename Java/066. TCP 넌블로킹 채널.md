# TCP 넌블로킹 채널

---

## 1. 개요

- ServerSocketChannel과 SocketChannel은 블로킹 방식과 넌블로킹 방식 둘 다 지원한다. 
- 넌블로킹 방식은 효율적인 서버 운영을 위해 중요하며, 여기서는 넌블로킹 방식의 특징과 이를 구현하는 핵심 객체인 Selector에 대해 설명한다.

---

## 2. 넌블로킹 방식의 특징

- 블로킹 방식에서는 클라이언트의 연결 요청이 없으면 accept() 메소드가 블로킹 상태로 대기하고, 클라이언트가 데이터를 보내지 않으면 read() 메소드도 블로킹 상태로 대기한다. 
- 이 때문에 각 클라이언트 연결마다 별도의 스레드를 할당해야 하므로 클라이언트가 많을수록 성능에 문제가 생길 수 있다. 
- 반면, 넌블로킹 방식에서는 connect(), accept(), read(), write() 메소드가 블로킹 없이 작동한다. 
- 예를 들어, 클라이언트가 연결을 요청하지 않으면 accept()는 null을 즉시 반환하고, 클라이언트가 데이터를 보내지 않으면 read()는 0을 반환하며 데이터는 저장되지 않는다.
- 다음 코드 예시는 클라이언트의 연결 요청이 없으면 무한 루프를 돌게 된다

```java
while(true) {
    SocketChannel socketChannel = serverSocketChannel.accept();
    ...
}
```
- 이 경우 accept() 메소드가 블로킹되지 않고 즉시 반환되므로, 클라이언트가 연결을 시도하지 않으면 while 문이 계속 실행되면서 CPU 자원을 낭비하게 된다. 
- 이를 해결하기 위해 Selector를 사용한다. Selector는 이벤트 리스너 역할을 하여, 클라이언트의 연결 요청이나 데이터 수신 등의 이벤트가 발생했을 때 이를 감지하여 해당 채널에 대한 처리를 지시한다.

---

## 3. 셀렉터 생성과 등록

- Selector는 멀티플렉서로, 여러 채널의 작업을 한 스레드에서 처리할 수 있게 해준다. 
- 채널은 Selector에 자신을 등록할 때, 작업 유형을 SelectionKey로 지정하고 이를 Selector의 관심 키셋에 추가한다. 
- 작업이 준비되면 Selector는 선택된 키셋에 해당 작업을 추가하고, 작업 스레드는 이를 처리한다.

### open() 메서드

- Selector 객체는 open() 메소드를 사용하여 생성한다. 
- open() 메소드는 IOException을 발생시킬 수 있으므로 예외 처리가 필요하다.
```java
try {
    Selector selector = Selector.open();
} catch (IOException e) {
    ...
}
```
- Selector에 등록할 수 있는 채널은 SelectableChannel의 하위 클래스만 가능하다. 
- 예를 들어, ServerSocketChannel, SocketChannel, DatagramChannel 등이 이에 해당하며, 넌블로킹으로 설정된 채널만 등록할 수 있다.

### 넌블로킹으로 설정하는 코드 예시

```java
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.configureBlocking(false);

SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);
```
- 채널을 Selector에 등록하는 방법은 register() 메소드를 사용한다. register()는 두 개의 매개변수를 받는다:
  - Selector 객체 
  - 작업 유형 (예: OP_ACCEPT, OP_READ, OP_WRITE 등)

```java
SelectionKey selectionKey = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
```

### 작업 유형에 따른 SelectionKey 상수

|SelectionKey 상수|	설명|
|:---:|:---:|
|OP_ACCEPT	|ServerSocketChannel의 연결 수락 작업|
|OP_CONNECT	|SocketChannel의 서버 연결 작업|
|OP_READ	|SocketChannel의 데이터 읽기 작업|
|OP_WRITE	|SocketChannel의 데이터 쓰기 작업|

### 작업 유형 등록

```java
SelectionKey selectionKey = serverSocketChannel.register(
    selector,
    SelectionKey.OP_ACCEPT
);
```
- ServerSocketChannel은 클라이언트 연결 수락 작업을 처리하므로 OP_ACCEPT를 사용한다.
```java
SelectionKey selectionKey = socketChannel.register(
    selector,
    SelectionKey.OP_CONNECT
);

SelectionKey selectionKey = socketChannel.register(
    selector,
    SelectionKey.OP_READ
);

SelectionKey selectionKey = socketChannel.register(
    selector,
    SelectionKey.OP_WRITE
);
```
- 주의
  - 동일한 SocketChannel에 대해 두 가지 이상의 작업 유형을 등록할 수 없다. 
  - 작업 유형이 변경되면 SelectionKey를 수정해야 한다. 등록은 한 번만 하며, 기존에 등록된 SelectionKey를 변경하여 사용한다.
- SelectionKey를 관리할 필요는 없으며, keyFor() 메소드를 통해 언제든지 SelectionKey를 얻을 수 있다:
```java
SelectionKey key = socketChannel.keyFor(selector);
```
- 이와 같이 Selector를 사용하면, 여러 채널을 효율적으로 관리하고, 넌블로킹 방식으로 서버 성능을 최적화할 수 있다.

---

## 4. 선택된 키셋

- Selector를 사용하려면 select() 메소드를 호출해야 한다.
- select() 메소드는 관심 키셋에 저장된 SelectionKey 중 작업 처리가 준비된 키가 있을 때까지 대기(블로킹)하며, 최소한 하나의 SelectionKey가 준비되면 리턴한다. 리턴 값은 준비된 SelectionKey의 수이다.
- select() 메소드에는 세 가지 종류가 있으며, 각각의 특징은 다음과 같다

|메소드|설명|
|:---:|:---:|
|int select()|하나 이상의 채널이 작업 처리 준비가 될 때까지 블로킹된다.|
|int select(long timeout)|주어진 시간(밀리세컨드) 동안만 블로킹된다.|
|int selectNow()|즉시 리턴한다.| 

- 작업 처리 준비된 채널이 있으면 그 채널의 수를 리턴하고, 없으면 0을 리턴한다. 
- 보통 첫 번째 select()를 사용하며, 블로킹이 발생하기 때문에 UI나 이벤트 처리 스레드에서 호출하지 말고 별도의 작업 스레드를 생성해 실행해야 한다.
- select()가 리턴되는 경우는 다음과 같다
  - 하나 이상의 채널이 작업 처리 준비가 되었을 때. 
  - Selector의 wakeup() 메소드가 호출된 경우. 
  - select()를 호출한 스레드가 인터럽트된 경우.


### 작업 유형 변경

- ServerSocketChannel은 작업 유형이 OP_ACCEPT 하나만 있지만, SocketChannel은 읽기(OP_READ)와 쓰기(OP_WRITE) 작업을 번갈아 가며 할 수 있다. 
- 작업 유형을 변경하려면 SelectionKey의 interestOps() 메소드를 사용하여 작업 유형을 수정하고, 변경된 작업 유형을 감지하기 위해 Selector의 wakeup() 메소드를 호출해야 한다.
```java
selectionKey.interestOps(SelectionKey.OP_WRITE);
selector.wakeup();
```

### 선택된 키셋 얻기

- select() 메소드가 리턴하면, selectedKeys() 메소드를 호출하여 준비된 SelectionKey들을 Set 컬렉션으로 얻을 수 있다. 이 Set이 바로 선택된 키셋이다.
```java
int keyCount = selector.select();
if (keyCount > 0) {
    Set<SelectionKey> selectedKeys = selector.selectedKeys();
}
```

---

## 5. 채널 작업 처리

- 작업 스레드는 선택된 키셋에서 SelectionKey를 하나씩 꺼내고, 해당 작업 유형에 맞는 채널 작업을 처리한다. 
- SelectionKey가 어떤 작업 유형인지를 확인하려면 다음 메소드들을 사용한다

|                   메소드                   |          설명           |
|:---------------------------------------:|:---------------------:|
|         boolean isAcceptable()          | 작업 유형이 OP_ACCEPT인 경우  |
|         boolean isConnectable()         | 작업 유형이 OP_CONNECT인 경우 |
|          boolean isReadable()           |  작업 유형이 OP_READ인 경우   |
| boolean isWritable()|  작업 유형이 OP_WRITE인 경우  |

- 작업 스레드가 채널 작업을 처리하는 예시는 다음과 같다
```java
Thread thread = new Thread() {  // 스레드 생성
    @Override
    public void run() {
        while (true) {
            try {
                int keyCount = selector.select(); // 작업 처리 준비된 키 감지
                if (keyCount == 0) {  // 키가 없을 경우 루프 처음으로 돌아감
                    continue;
                }
                // 선택된 키셋 얻기
                Set<SelectionKey> selectedKeys = selector.selectedKeys();
                // 반복자 얻기
                Iterator<SelectionKey> iterator = selectedKeys.iterator();  
                while (iterator.hasNext()) {
                    SelectionKey selectionKey = iterator.next(); // 키를 하나씩 꺼냄
                    if (selectionKey.isAcceptable()) {
                        // 연결 수락 작업 처리
                    }
                    else if (selectionKey.isReadable()) {
                        // 읽기 작업 처리
                    }
                    else if (selectionKey.isWritable()) {
                        // 쓰기 작업 처리
                    }
                    // 선택된 키셋에서 처리 완료된 SelectionKey를 제거
                    iterator.remove();
                }
            }
            catch (Exception e) {
                break;
            }
        }
    }
};  
thread.start();  // 스레드 실행
```

### 채널 객체 얻기

- 작업 스레드가 채널 작업을 처리하려면, SelectionKey에서 채널 객체를 얻어야 한다. 
  - 이를 위해 SelectionKey의 channel() 메소드를 사용한다. 
- 예를 들어, OP_ACCEPT 작업 유형일 경우 ServerSocketChannel을 얻는 코드는 다음과 같다.

```java
ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();
```

### 첨부 객체 사용

- 작업 스레드가 채널 작업을 처리하다 보면 채널 객체 외에 다른 객체가 필요할 수도 있다. 
- 이런 객체는 SelectionKey에 첨부하여 사용할 수 있다.
- 객체를 첨부하는 방법은 SelectionKey의 attach() 메소드를 사용하고, 첨부된 객체를 얻으려면 attachment() 메소드를 사용한다.
- 예시 코드

```java
// [객체 첨부하기]
Client client = new Client(socketChannel);
SelectionKey selectionKey = socketChannel.register(
    selector,
    SelectionKey.OP_READ
);
selectionKey.attach(client);  // 객체를 첨부

// [첨부된 객체 얻기]
if (selectionKey.isReadable()) {
    Client client = (Client) selectionKey.attachment();  // 첨부된 객체 얻기
    ...
}
```

---

### 참고자료

[이것이 자바다](https://search.shopping.naver.com/book/catalog/32473359191?query=%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%B0%94%EB%8B%A4&NaPm=ct%3Dm7ne3c9k%7Cci%3D6356ea398110d474e244102192a893d910277fb2%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Da51fed5127109d9f5a3bd6af6be4725cd7500518)