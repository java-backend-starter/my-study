# 파일 채널

---

## 1. 파일 채널(FileChannel)

- `FileChannel`을 사용하면 파일을 읽고 쓸 수 있으며, 멀티 스레드 환경에서도 안전하다.

### FileChannel 생성과 종료

#### 생성 방법

- FileChannel은 두 가지 방법으로 생성할 수 있다.

##### `FileChannel.open()` 사용

```java
FileChannel fileChannel = FileChannel.open(Path path, OpenOption... options);
```
- `path`: 열거나 생성할 파일의 경로 (`Path` 객체)
- `options`: 파일 열기 옵션 (`StandardOpenOption` 열거 상수)

| 옵션 | 설명 |
| --- | --- |
| READ | 읽기 전용 |
| WRITE | 쓰기 전용 |
| CREATE | 파일이 없으면 생성 |
| CREATE_NEW | 새 파일 생성, 이미 존재하면 예외 발생 |
| APPEND | 파일 끝에 추가 (WRITE 또는 CREATE와 함께) |
| DELETE_ON_CLOSE | 채널 종료 시 파일 삭제 |
| TRUNCATE_EXISTING | 기존 파일을 0바이트로 초기화 (WRITE와 함께) |

##### 예제: 새 파일 생성 후 쓰기

```java
FileChannel fileChannel = FileChannel.open(
    Paths.get("C:/Temp/file.txt"),
    StandardOpenOption.CREATE_NEW,
    StandardOpenOption.WRITE
);
```

##### 예제: 읽기/쓰기 가능 파일 열기

```java
FileChannel fileChannel = FileChannel.open(
    Paths.get("C:/Temp/file.txt"),
    StandardOpenOption.READ,
    StandardOpenOption.WRITE
);
```

##### 종료

```java
fileChannel.close();
```

### 파일 쓰기

- `FileChannel.write(ByteBuffer src)`를 사용하여 버퍼의 `position`부터 `limit`까지 바이트를 파일에 쓴다. 
- 반환값은 쓰기 성공한 바이트 수이다.

#### 예제: 문자열 쓰기

```java
Path path = Paths.get("C:/Temp/file.txt");
Files.createDirectories(path.getParent());

FileChannel fileChannel = FileChannel.open(
    path,
    StandardOpenOption.CREATE,
    StandardOpenOption.WRITE
);

String data = "안녕하세요";
ByteBuffer byteBuffer = Charset.defaultCharset().encode(data);

int byteCount = fileChannel.write(byteBuffer);
System.out.println("file.txt : " + byteCount + " bytes written");

fileChannel.close();
```

### 파일 읽기

- `FileChannel.read(ByteBuffer dst)`를 사용하여 파일에서 바이트를 읽어 `ByteBuffer`에 저장한다. 
- 반환값은 읽은 바이트 수, 더 이상 읽을 바이트가 없으면 `-1`을 반환한다.
- `flip()` : 읽기 전환, `limit = position`, `position = 0`
- `clear()` : 버퍼 초기화, `position = 0`, `limit = capacity`

#### 예제: 파일 읽기

```java
Path path = Paths.get("C:/Temp/file.txt");

FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ);
ByteBuffer byteBuffer = ByteBuffer.allocate(100);

Charset charset = Charset.defaultCharset();
String data = "";
int byteCount;

while ((byteCount = fileChannel.read(byteBuffer)) != -1) {
    byteBuffer.flip();
    data += charset.decode(byteBuffer).toString();
    byteBuffer.clear();
}

fileChannel.close();
System.out.println("file.txt : " + data);
```

---

## 2. 파일 복사(File Copy)

- 파일 복사는 하나의 `ByteBuffer`를 사이에 두고, 읽기용 `FileChannel`과 쓰기용 `FileChannel`이 번갈아 가며 수행하도록 구현할 수 있다.

### FileChannel을 이용한 파일 복사

#### 예제: 이미지 파일 복사

```java
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class FileCopyExample {
    public static void main(String[] args) throws IOException {
        Path from = Paths.get("src/sec04/exam02_file_copy/house1.jpg");
        Path to = Paths.get("src/sec04/exam02_file_copy/house2.jpg");

        FileChannel fileChannel_from = FileChannel.open(from, StandardOpenOption.READ);
        FileChannel fileChannel_to = FileChannel.open(to,
            StandardOpenOption.CREATE,
            StandardOpenOption.WRITE
        );

        ByteBuffer buffer = ByteBuffer.allocateDirect(100);
        int byteCount;

        while (true) {
            buffer.clear();
            byteCount = fileChannel_from.read(buffer);
            if (byteCount == -1) break;
            buffer.flip();
            fileChannel_to.write(buffer);
        }

        fileChannel_from.close();
        fileChannel_to.close();

        System.out.println("파일 복사 성공");
    }
}
```
- 다이렉트 버퍼(`allocateDirect`) 사용 시 I/O 성능 향상
- Eclipse 실행 시 새 파일이 보이지 않으면 **F5로 새로고침** 필요

### Files.copy()를 이용한 간단한 복사

- 단순 복사 목적이라면 `Files.copy()`가 더 편리하다.

```java
Path targetPath = Files.copy(Path source, Path target, CopyOption... options);
```

| 옵션 | 설명 |
| --- | --- |
| REPLACE_EXISTING | 타겟 파일이 존재하면 덮어씀 |
| COPY_ATTRIBUTES | 파일 속성까지 복사 |
| NOFOLLOW_LINKS | 심볼릭 링크는 복사하지 않음 |

#### 예제: Files.copy() 사용

```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

Path source = Paths.get("src/sec04/exam02_file_copy/house1.jpg");
Path target = Paths.get("src/sec04/exam02_file_copy/house2.jpg");

Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
System.out.println("파일 복사 성공");
```

---

## 3. 핵심 요약

- FileChannel은 동기화된 I/O 채널**, 멀티 스레드 안전
- 읽기/쓰기/복사 모두 ByteBuffer 기반
- `write()` → ByteBuffer → 파일, `read()` → 파일 → ByteBuffer
- 버퍼 상태 관리 (`flip()`, `clear()`) 중요
- 직접 FileChannel을 쓰면 세밀한 제어 가능, 단순 복사는 `Files.copy()` 활용이 편리
- 다이렉트 버퍼 사용 시 성능 향상


---

### 참고자료

[이것이 자바다](https://search.shopping.naver.com/book/catalog/32473359191?query=%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%9E%90%EB%B0%94%EB%8B%A4&NaPm=ct%3Dm7ne3c9k%7Cci%3D6356ea398110d474e244102192a893d910277fb2%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Da51fed5127109d9f5a3bd6af6be4725cd7500518)