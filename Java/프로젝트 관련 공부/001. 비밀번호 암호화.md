# 비밀번호 암호화

---

## 1. 암호화(Encryption) 종류

- 암호화는 데이터를 보호하기 위해 변환하는 과정이다. 
- 암호화는 크게 양방향 암호화와 단방향 암호화로 나눌 수 있다.

### 양방향 암호화

- 정의: 암호화한 데이터를 복호화할 수 있는 방식.
- 특징:
    - 데이터 암호화 후 원래 값으로 복원 가능.
    - 사용 예: 데이터 전송, 파일 저장, 메시지 통신.
- 종류:
    - 대칭키 방식: 암호화와 복호화에 같은 키 사용.
        - 예: AES, DES
        - 장점: 속도 빠름, 구현 단순
        - 단점: 키 관리 어려움
    - 비대칭키 방식: 암호화와 복호화에 다른 키 사용 (공개키, 개인키)
        - 예: RSA, DSA
        - 장점: 안전하게 키 배포 가능
        - 단점: 연산 속도 느림

### 단방향 암호화

- 정의: 암호화 후 복호화가 불가능한 방식, 일반적으로 해시(Hash) 알고리즘 사용.
- 특징:
    - 입력값이 무엇이든 출력 길이는 고정됨.
        - 예: SHA256 → 항상 256비트 출력
    - 보통 패스워드 저장에 사용
- 단점:
    - 동일한 입력 → 동일한 출력 → 공격자가 테이블(레인보우 테이블) 만들어 쉽게 복원 가능
    - 이를 방지하기 위해 Salt를 함께 사용

---

## 2. 해시(Hash)와 단방향 암호화

### 해시 함수

- 입력 데이터를 일정한 길이의 고정 값으로 변환하는 함수
- 특징:
  - Deterministic: 같은 입력이면 같은 출력
  - 고정 길이 출력: 입력 길이와 상관없이 출력 길이는 고정
  - 사용 : 메시지 인증, 무결성 검증 등에 사용
  - 충돌 가능성 존재: 서로 다른 입력이 동일한 해시값을 가질 수 있음 → 해시 충돌(Hash Collision)
  - 단방향 암호화라서 원래 데이터로 복호화할 수 없다.
  - 기본적으로 처리 속도가 매우 빠르다. 그렇기에 공격자 브루트포스에 취약하다.
  - 해시 결과값을 digest, checksum, digital fingerprint라고 부른다.
  - 예: SHA256, SHA512, MD5 등

### 단방향 암호화 사용 이유

- 서버 DB에 실제 비밀번호 저장하지 않음 → 해킹 위험 감소
- 로그인 시 비교 방식:
    1. 사용자가 입력한 비밀번호를 해시 처리
    2. DB에 저장된 해시값과 비교
    3. 일치하면 로그인 허용

### 해시 함수 구현 : MessageDigest 알고리즘

- MessageDigest는 다양한 해시 알고리즘을 지원하고 SHA-256 같은 표준 해시를 쉽게 사용할 수 있게 하는 인터페이스다.

```java
@SneakyThrows
static String encrypt(String message) {
    final MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
    messageDigest.update(message.getBytes());
    return new String(Base64.getEncoder().encode(messageDigest.digest()));
}
```

#### 지원 알고리즘

- MD2 : RFC 1319 정의
- MD5 : RFC 1321 정의
- SHA 계열 (SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256)
  - FIPS PUB 180-4 정의 
  - SHA-1: 160bit digest 
  - 다른 SHA 계열은 이름 그대로 비트 길이
- SHA-3 계열 (SHA3-224, SHA3-256, SHA3-384, SHA3-512)
  - FIPS PUB 202에서 정의 
  - 순열 기반, 출력 길이 확장 가능 구조

#### Avalanche Effect

- 입력값이 조금만 바뀌어도 출력값이 완전히 달라지는 현상.
- 예시:
  - "hello jiniworld" → fBWgim+2DAp0+01x5Ylpr9pPFC7zbx5GMmofaw5+sGI=
  - "hello jiniworld!" → A7Z8clE8u2kBxXxYgArInfN49/VKiOjFXw5zXXvW74g=
  - 단 하나의 문자 차이인데 해시값이 전혀 다르게 바뀐다.
- 이런 속성이 강할수록 해시 알고리즘의 보안성도 강해진다.

#### MessageDigest(SHA-256 등)의 단점

- 레인보우 공격 취약 
  - 해시 함수는 같은 입력 → 같은 출력 구조다. 
  - 해시값이 대량 유출되면 공격자는 레인보우 테이블로 원문을 유추할 수 있다.
- 너무 빠르다
  - 해시 함수는 원래 검색 최적화를 위해 설계돼 처리 속도가 매우 빠르다. 
  - 예: MD5는 일반 PC에서도 1초에 수십억 번 추론 가능. 
  - 빠른 연산 속도는 공격자에게 유리하여, 짧거나 단순한 비밀번호는 더 위험해진다.

---

## 3. 해시 크기와 충돌

### 해시 공간 크기

- 해시 비트 수에 따른 경우의 수:
    - 2비트 → 2² = 4개
    - 32비트 → 2³² ≈ 43억 개
    - 64비트 → 2⁶⁴ ≈ 1.8 × 10¹⁹ 개
    - 256비트(SHA256) → 2²⁵⁶ ≈ 1.15 × 10⁷⁷ 개
- 해시 공간이 크면 충돌 확률 낮음

### 해시 충돌(Hash Collision)

- 서로 다른 입력이 동일한 해시값으로 변환되는 상황
- SHA256은 256비트라 충돌 가능성은 매우 낮지만, 완전히 불가능하지 않음

---

## 4. 해시 함수 구현 : MessageDigest 알고리즘

- MessageDigest는 다양한 해시 알고리즘을 지원하고 SHA-256 같은 표준 해시를 쉽게 사용할 수 있게 하는 인터페이스다.

```java
@SneakyThrows
static String encrypt(String message) {
    final MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");
    messageDigest.update(message.getBytes());
    return new String(Base64.getEncoder().encode(messageDigest.digest()));
}
```

### 지원 알고리즘

- MD2 : RFC 1319 정의
- MD5 : RFC 1321 정의
- SHA 계열 (SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256)
    - FIPS PUB 180-4 정의
    - SHA-1: 160bit digest
    - 다른 SHA 계열은 이름 그대로 비트 길이
- SHA-3 계열 (SHA3-224, SHA3-256, SHA3-384, SHA3-512)
    - FIPS PUB 202에서 정의
    - 순열 기반, 출력 길이 확장 가능 구조

### Avalanche Effect

- 입력값이 조금만 바뀌어도 출력값이 완전히 달라지는 현상.
- 예시:
    - "hello jiniworld" → fBWgim+2DAp0+01x5Ylpr9pPFC7zbx5GMmofaw5+sGI=
    - "hello jiniworld!" → A7Z8clE8u2kBxXxYgArInfN49/VKiOjFXw5zXXvW74g=
    - 단 하나의 문자 차이인데 해시값이 전혀 다르게 바뀐다.
- 이런 속성이 강할수록 해시 알고리즘의 보안성도 강해진다.

### MessageDigest(SHA-256 등)의 단점

#### 레인보우 공격 취약

- 레인보우 테이블은 “원본 문자열 ↔ 해시값” 쌍을 대량으로 저장해 놓은 표이다.
- 해시 알고리즘의 약점 중 하나는 동일한 입력값이면 동일한 해시값이 생성된다는 점이다.
- 이 특성을 이용해 미리 해시값과 원본 문자열을 짝지어 저장해 두면 해시값만 보고 원본을 추정할 수 있다.
- 해시값이 대량 유출되면 공격자는 레인보우 테이블로 원문을 유추할 수 있다.

#### 너무 빠르다

- 해시 함수는 원래 검색 최적화를 위해 설계돼 처리 속도가 매우 빠르다.
- 예: MD5는 일반 PC에서도 1초에 수십억 번 추론 가능.
- 빠른 연산 속도는 공격자에게 유리하여, 짧거나 단순한 비밀번호는 더 위험해진다.
 
### MessageDigest 보완 방식

#### Salt

- 단방향 해시 생성 시 함께 사용하는 임의의 바이트 문자열. 
- Salt가 포함되면 같은 비밀번호라도 다른 해시가 나오므로 레인보우 공격을 방지한다. 
- 각 원문마다 랜덤한 Salt를 생성하고 충분한 길이를 확보해야 한다.

#### Key Stretching

- 해시를 한 번만 계산하지 않고, N번 반복해서 해싱 속도를 일부러 느리게 만든다. 
- 브루트포스 공격을 어렵게 하기 위한 방식. 
- 보통 0.2초 이상 걸리도록 반복 횟수를 조절하는 것이 권장됨. 
- Salt와 함께 사용한다.

---

## 5. Salt(솔트)

### 정의

- 솔트는 무작위로 생성된 문자열이며, 비밀번호에 추가해 함께 해시하는 방식이다.
- 사용 이유: 동일한 비밀번호라도 솔트를 포함하면 서로 다른 해시값이 생성되기 때문에 레인보우 테이블에 존재할 가능성이 현저히 낮아진다.
- 주의사항: 솔트값은 각 사용자마다 고유해야 하고, 무작위성이 충분해야 한다.

### 사용 예시

- 비밀번호: `123123`
- Salt: `fuxxhackerbyehacker1@!`
- 처리: `123123 + fuxxhackerbyehacker1@!` → SHA256 해시 생성 → DB 저장
- 장점:
    - 같은 비밀번호라도 다른 사용자는 서로 다른 해시값 저장
    - 사전 공격이나 레인보우 테이블 공격 무력화

### 로그인 과정

1. 사용자 비밀번호를 입력받는다.
2. 랜덤 또는 고유한 솔트값을 생성하여 저장한다.
3. 비밀번호 + 솔트에 SHA-256 해시를 적용한 값을 DB에 저장한다.
4. 로그인 시 입력 비밀번호 + 저장된 솔트를 해시하여 DB의 값과 비교한다.

---

## 6. Adaptive Key Derivation Function

- Salt + Key Stretching을 기본으로 포함한 강력한 암호화 함수.

### PBKDF2

- 표준(Key Derivation Function)이며 ISO-27001을 준수한다. 
- HmacSHA1, SHA256, SHA512 기반 버전이 존재한다. 
- password + random salt + 반복 횟수(iteration count)를 기반으로 생성된 값이 최종 Key.

#### Pbkdf2PasswordEncoder (Spring Security)

- Spring Security가 제공하는 구현체. 
- encode(rawPassword)로 쉽게 PBKDF2 해시를 생성한다. 
- decode는 불가능하지만 matches()로 비교할 수 있다다. 
- 기본 알고리즘은 PBKDF2WithHmacSHA1. 
- Base64/Hex 출력을 선택할 수 있다.
- 코드 흐름 
  - SECRET_KEY, 반복 횟수, 해시 길이, salt 길이 등을 설정 
  - encode(raw) 호출 → Salt 자동 생성 → Base64 인코딩된 digest 반환 
  - 매번 salt가 달라서 같은 비밀번호도 매번 다른 결과 출력 
  - matches(raw, encoded)로 인증

#### SecretKeyFactory + PBEKeySpec 직접 구현

- Spring Security 없이 PBKDF2를 직접 구현한 방식. 
- password + salt + SECRET_KEY + iteration + hash width를 조합해 SecretKey를 생성한다. 
- 랜덤 salt 생성 후 digest 앞부분에 salt를 붙여서 저장한다. 
- matches() 시 Base64 디코딩 → salt 추출 → 동일 조건으로 다시 해싱 → 비교
- 중요 포인트 
  - salt는 따로 저장하거나, 결과에 포함해야 매칭할 수 있다.
  - encode 결과는 salt + digest로 이루어진다.

### bcrypt

- Blowfish 기반 해시 함수. 비밀번호 저장용으로 설계됐다. 
- JCA는 지원하지 않고 Spring Security 등 라이브러리에서 제공한다.
- bcrypt digest는 `버전 + cost factor(키 스트레칭 횟수) + salt + hash 구조`이다.
- salt가 매번 다르기 때문에 같은 비밀번호도 매번 다른 암호문이 나온다. 
- 결과끼리 비교는 불가능하고 rawPassword로 matches()만 가능.
- 코드 특징 
  - 기본 버전: $2A, 기본 cost=10 
  - 예제는 $2B, cost=12 사용 
  - bcrypt.encode(raw) → 다른 값이지만 둘 다 matches(raw, encoded)는 true

---

## 6. 코드 예시

### SHA-256 + Salt

#### SHA-256 알고리즘

- SHA-256은 해시값을 이용한 단방향 암호화 알고리즘 중 하나이다. 
  - 단방향이라는 말은 암호화는 가능하지만 복호화는 불가능하다는 뜻이다.
- 예시: 입력값이 “ABC”이면 SHA-256을 적용해 “4d35adf24fe634er…” 같은 64자리 문자열로 출력될 수 있다.
- 이 방식은 비밀번호를 직접 DB에 저장하는 대신 해시된 문자열을 저장함으로써 보안성을 높인다.


#### SHA-256 알고리즘 + Salt 적용 코드

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

public class Encrypt {

    public static void main(String[] args) {
        Encrypt en = new Encrypt();

        String pwd = "my_password_good";
        System.out.println("pwd : "+ pwd);

        // Salt 생성
        String salt = en.getSalt();
        System.out.println("salt : "+salt);

        // 최종 해시된 비밀번호 생성
        String res = en.getEncrypt(pwd, salt);
    }

    // Salt 생성 메서드
    public String getSalt() {

        // 1. 보안을 위한 난수 생성기 (SecureRandom) 준비
        SecureRandom r = new SecureRandom();

        // 2. 20바이트(160비트) 크기의 난수 배열 생성
        byte[] salt = new byte[32];

        // 3. 난수 채우기
        r.nextBytes(salt);

        // 4. byte 배열을 16진수(hex) 문자열로 변환
        StringBuffer sb = new StringBuffer();
        for(byte b : salt) {
            sb.append(String.format("%02x", b));
        }

        return sb.toString();  // 최종 salt 문자열 반환
    }

    // 비밀번호 + Salt 해시(SHA-256) 생성 메서드
    public String getEncrypt(String pwd, String salt) {

        String result = "";
        try {
            // 1. SHA-256 해시 객체 생성
            MessageDigest md = MessageDigest.getInstance("SHA-256");

            // 2. 비밀번호 + Salt 합친 문자열을 SHA-256 해시 처리
            System.out.println("pwd + salt 적용 전 : " + pwd + salt);
            md.update((pwd + salt).getBytes());
            byte[] pwdsalt = md.digest();  // 해시 결과 (byte 배열)

            // 3. byte 배열을 16진수(hex) 문자열로 변환
            StringBuffer sb = new StringBuffer();
            for (byte b : pwdsalt) {
                sb.append(String.format("%02x", b));
            }

            result = sb.toString();
            System.out.println("pwd + salt 적용 후 : " + result);

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        return result;  // 최종 해시값 반환
    }
}
```

---

### 출처

[페스워드 암호와 기본이론](https://study-easy-coding.tistory.com/153#Salt%20%EB%9E%80%3F%20(%EB%8B%A8%EB%B0%A9%ED%96%A5%20%EC%95%94%ED%98%B8%ED%99%94%20%2B%20Salt)-1-5)

[SHA-256 + Salt 개념 및 예제](https://cceeun.tistory.com/241#google_vignette)

[해시 함수와 이를 보완하는 것](https://blog.jiniworld.me/172#a01-2)