# BigDemical

---

## 1. BigDecimal

- BigDecimal은 Java 언어에서 숫자를 정밀하게 저장하고 표현할 수 있는 유일한 방법이다.
- 소수점을 저장할 수 있는 가장 크기가 큰 타입인 double은 소수점의 정밀도에 있어 한계가 있어 값이 유실될 수 있다.
    - 돈과 소수점을 다룬다면 BigDecimal은 선택이 아니라 필수이다.
- BigDecimal의 유일한 단점은 느린 속도와 기본 타입보다 조금 불편한 사용법 뿐이다.

### double, 무엇이 문제인가?

- 소수점 이하의 수를 다룰 때 double 타입은 사칙연산시 아래와 같이 우리가 기대한 값과 다른 값을 출력한다. 
    - 이유는 double 타입이 내부적으로 수를 저장할 때 이진수의 근사치를 저장하기 때문이다.
- BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 아주 작은 수과 큰 수의 연산에 대해 거의 무한한 정밀도를 보장한다.

```java
double a = 10.0000;
double b = 3.0000;

// 기대값: 13
// 실제값: 13.000001999999999
a + b;

// 기대값: 7
// 실제값: 6.999999999999999
a - b;

// 기대값: 30
// 실제값: 30.000013000000997
a * b;

// 기대값: 3.33333...
// 실제값: 3.333332555555814
a / b;
```

### BigDecimal 기본 용어

#### precision

- 왼쪽부터 0이 아닌 수가 시작하는 위치부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 자리수이다. unscale과 동의어이다. 
- 예: 012345.67890의 precision은 11이 아닌 9이다.

#### scale

- 소수점 첫째 자리부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수이다. fraction과 동의어이다. 
- 예: 012345.67890의 scale은 4이다. 하지만 0.00, 0.0의 scale은 모두 1이다.
- BigDecimal은 32bit의 소수점 크기를 가진다.

#### DECIMAL128

- IEEE 754-2008에 의해 표준화된, 부호와 소수점을 수용하며, 최대 34자리까지 표현 가능한 10진수를 저장할 수 있는 형식이다. 
- 금융권에서 처리되는 대부분의 금액을 수용할 수 있는 크기이다. 
- Java에서는 BigDecimal 타입을 통해 공식적으로 지원한다.

### BigDecimal 기본 상수

- float, double 타입과 다르게 BigDecimal 타입은 초기화가 장황한 편이다. 
- 그래서, 자주 쓰는 0, 1, 100은 쓰기 편하게 미리 상수로 정의되어 있다.

```java
// 흔히 쓰이는 값은 상수로 정의
// 0
BigDecimal.ZERO

// 1
BigDecimal.ONE

// 10
BigDecimal.TEN
```

### BigDecimal 초기화

- double 타입으로 부터 BigDecimal 타입을 초기화하는 방법으로 가장 안전한 것은 문자열의 형태로 생성자에 전달하여 초기화하는 것이다. 
- double 타입의 값을 그대로 전달할 경우 앞서 사칙연산 결과에서 본 것과 같이 이진수의 근사치를 가지게 되어 예상과 다른 값을 얻을 수 있다. 
```java
// double 타입을 그대로 초기화하면 기대값과 다른 값을 가진다.
// 0.01000000000000000020816681711721685132943093776702880859375
new BigDecimal(0.01);

// 문자열로 초기화하면 정상 인식
// 0.01
new BigDecimal("0.01");

// 위와 동일한 결과, double#toString을 이용하여 문자열로 초기화
// 0.01
BigDecimal.valueOf(0.01);
```

### BigDecimal 비교 연산

- BigDecimal은 기본 타입이 아닌 오브젝트이기 때문에 특히, 동등 비교 연산을 유의해야 한다. 
- double 타입을 사용하던 습관대로 무의식적으로 == 기호를 사용하면 예기치 않은 연산 결과를 초래할 수 있다.

```java
BigDecimal a = new BigDecimal("2.01");
BigDecimal b = new BigDecimal("2.010");

// 객체의 레퍼런스 주소에 대한 비교 연산자로 무의식적으로 값의 비교를 위해 사용하면 오동작
// false
a == b;

// 값의 비교를 위해 사용, 소수점 맨 끝의 0까지 완전히 값이 동일해야 true 반환
// false
a.equals(b);

// 값의 비교를 위해 사용, 소수점 맨 끝의 0을 무시하고 값이 동일하면 0, 적으면 -1, 많으면 1을 반환
// 0
a.compareTo(b);
```

### BigDecimal 사칙 연산

- Java에서 BigDecimal 타입의 사칙 연산 방법은 아래와 같다.

```java 
BigDecimal a = new BigDecimal("10");
BigDecimal b = new BigDecimal("3");

// 더하기
// 13
a.add(b);

// 빼기
// 7
a.subtract(b);

// 곱하기
// 30
a.multiply(b);

// 나누기
// 3.333333...
// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
a.divide(b);

// 나누기
// 3.333
a.divide(b, 3, RoundingMode.HALF_EVEN);

// 나누기 후 나머지
// 전체 자리수를 34개로 제한
// 1
a.remainder(b, MathContext.DECIMAL128);

// 절대값
// 3
new BigDecimal("-3").abs();

// 두 수 중 최소값
// 3
a.min(b);

// 두 수 중 최대값
// 10
a.max(b);
```

### BigDecimal 소수점 처리

- RoundingMode.HALF_EVEN은 Java의 기본 반올림 정책으로 금융권에서 사용하는 Bankers Rounding와 동일한 알고리즘이다. 
- 금융권에서는 시스템 개발시 혼란을 막기 위해 요구사항에 반올림 정책을 명확히 명시하여 개발한다.

```java
// 소수점 이하를 절사한다.
// 1
new BigDecimal("1.1234567890").setScale(0, RoundingMode.FLOOR);

// 소수점 이하를 절사하고 1을 증가시킨다.
// 2
new BigDecimal("1.1234567890").setScale(0, RoundingMode.CEILING);
// 음수에서는 소수점 이하만 절사한다.
// -1
new BigDecimal("-1.1234567890").setScale(0, RoundingMode.CEILING);

// 소수점 자리수에서 오른쪽의 0 부분을 제거한 값을 반환한다.
// 0.9999
new BigDecimal("0.99990").stripTrailingZeros();

// 소수점 자리수를 재정의한다.
// 원래 소수점 자리수보다 작은 자리수의 소수점을 설정하면 예외가 발생한다.
// java.lang.ArithmeticException: Rounding necessary
new BigDecimal("0.1234").setScale(3);

// 반올림 정책을 명시하면 예외가 발생하지 않는다.
// 0.123
new BigDecimal("0.1234").setScale(3, RoundingMode.HALF_EVEN);

// 소수점을 남기지 않고 반올림한다.
// 0
new BigDecimal("0.1234").setScale(0, RoundingMode.HALF_EVEN);
// 1
new BigDecimal("0.9876").setScale(0, RoundingMode.HALF_EVEN);
```

### BigDecimal 나누기 처리

```java
BigDecimal b10 = new BigDecimal("10");
BigDecimal b3 = new BigDecimal("3");

// 나누기 결과가 무한으로 떨어지면 예외 발생
// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.
b10.divide(b3);

// 반올림 정책을 명시하면 예외가 발생하지 않음
// 3
b10.divide(b3, RoundingMode.HALF_EVEN);

// 반올림 자리값을 명시
// 3.333333
b10.divide(b3, 6, RoundingMode.HALF_EVEN);

// 3.333333333
b10.divide(b3, 9, RoundingMode.HALF_EVEN);

// 전체 자리수를 7개로 제한하고 HALF_EVEN 반올림을 적용한다.
// 3.333333
b10.divide(b3, MathContext.DECIMAL32);

// 전체 자리수를 16개로 제한하고 HALF_EVEN 반올림을 적용한다.
// 3.333333333333333
b10.divide(b3, MathContext.DECIMAL64);

// 전체 자리수를 34개로 제한하고 HALF_EVEN 반올림을 적용한다.
// 3.333333333333333333333333333333333
b10.divide(b3, MathContext.DECIMAL128);

// 전체 자리수를 제한하지 않는다.
// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. 예외가 발생한다.
b10.divide(b3, MathContext.UNLIMITED);
```

---

## 2. MySQL과 BigDecimal

- MySQL 또한 Java와 동일한 문제를 가지고 있다. 
- FLOAT, DOUBLE 타입에 소수를 가진 수를 저장할 경우 앞서와 동일한 연산의 정확도 문제가 발생한다. 
- 이를 해결하기 위해 MySQL은 BigDecimal 타입에 대응하는 DECIMAL 타입을 제공한다. 
- 컬럼 선언 방법은 아래와 같다.
```sql
foo DECIMAL(5,2) DEFAULT 0.00 NOT NULL
```
- DECIMAL 타입 선언시 괄호 안의 숫자의 의미는 PRECISION, SCALE을 의미한다. 
    - (5,2)의 경우 전체 자리수는 5, 소수점 이하 자리수는 2로 선언하겠다는 의미이다.
    - (-999.99~999.99) 괄호를 생략하는 것도 가능한데 이 경우 기본값으로 (10,0)이 적용된다. 
    - PRECISION의 최대값은 65로 산업 표준인 DECIMAL128을 충분히 수용할 수 있다. SCALE의 최대값은 30으로 PRECISION보다 클 수 없다.
- 만약, 지정된 소수 자리수보다 많은 값을 저장할 경우, 지정된 소수 자리수 이하는 절사(floor)된다. 
- 절사보다 반올림을 선호할 경우, 바로 아래 설명한 애플리케이션 레벨에서의 반올림 처리를 하면 된다.

---

## 3. JPA에서의 BigDecimal 처리

- JDBC에서 MySQL/MariaDB의 DECIMAL 타입은 ResultSet 인터페이스의 getBigDecimal(), getString() 2개 메써드로 획득이 가능하다. 
- JPA 또한 별도의 작업 없이 엔티티 필드에 BigDecimal 타입을 사용하여 처리하면 된다.
- 만약, 데이터베이스 저장시 소수점 이하 자리수와 반올림 방법을 자동으로 처리되게 하고 싶다면 JPA가 제공하는 커스텀 컨버터를 제작하면 된다. 
```java
// 소수점 이하 6자리에서 Bankers Rounding을 적용하여 BigDecimal 값을 생성한 후 데이터베이스에 저장하는 역할의 컨버터
import javax.persistence.AttributeConverter;
import javax.persistence.Converter;
import java.math.BigDecimal;
import java.math.RoundingMode;

@Converter
public class BigDecimalScale6WithBankersRoundingConverter
        implements AttributeConverter<BigDecimal, String> {

    private static final int SCALE_SIX = 6;
    private static final RoundingMode BANKERS_ROUNDING_MODE = RoundingMode.HALF_EVEN;

    @Override
    public String convertToDatabaseColumn(BigDecimal attribute) {

        if (attribute == null) {
            return null;
        }

        if (attribute.scale() == SCALE_SIX) {
            return attribute.toString();
        }

        return attribute
                .setScale(SCALE_SIX, BANKERS_ROUNDING_MODE)
                .toString();
    }

    @Override
    public BigDecimal convertToEntityAttribute(String dbData) {

        if (dbData == null) {
            return null;
        }

        return new BigDecimal(dbData);
    }
}

```
- 작성한 커스텀 컨버터를 엔티티에 적용하는 예는 아래와 같다.
```java
// DECIMAL(21,6) 타입에 대한 매핑 상세 정의
// 숫자 범위는 -999999999999999.999999 ~ +999999999999999.999999
@Column(name = "foo", nullable = false, precision = 21, scale = 6)
@Digits(integer = 15, fraction = 6)
@Convert(converter = BigDecimalScale6WithBankersRoundingConverter.class)
private BigDecimal foo = BigDecimal.ZERO;
```

---

## 출처

[BigDemical](https://jsonobject.tistory.com/466)