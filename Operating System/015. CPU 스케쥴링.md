# CPU 스케쥴링

---

## 1. 개요

- 사용자 프로그램은 CPU 작업과 I/O 작업이 반복되는 형태로 수행됨
- CPU 작업은 빠르게 처리되며, I/O 작업은 느린 입출력 장치를 필요로 함
- 이러한 작업의 반복을 각각 다음과 같이 정의함:
    - CPU 버스트: 사용자 프로그램이 직접 CPU를 사용하여 빠른 명령을 수행하는 단계
    - I/O 버스트: 운영체제 커널이 입출력 작업을 수행하는 비교적 느린 단계
- 프로세스의 유형
    - CPU 바운드 프로세스: CPU 버스트가 긴 계산 위주의 프로그램
    - I/O 바운드 프로세스: I/O 요청이 빈번한 대화형 프로그램
- 효율적인 CPU 스케줄링의 목표
    - 다양한 프로세스 특성을 고려하여 CPU와 I/O 장치의 이용률을 최대화
    - 특히 I/O 바운드 프로세스에게 우선적으로 CPU를 할당하여 전체 시스템의 효율성 향상

---

## 2. CPU 스케줄링 성능 지표

- CPU 이용률 (CPU Utilization): 전체 시간 중 CPU가 실제 작업을 수행한 비율
- 처리량 (Throughput): 일정 시간 동안 완료된 프로세스의 수
- 대기 시간 (Waiting Time): 프로세스가 준비 큐에서 CPU를 기다린 총 시간
- 소요 시간 (Turnaround Time): 프로세스가 시작되어 모든 작업을 마칠 때까지의 시간
- 응답 시간 (Response Time): 준비 큐에 들어온 후 처음으로 CPU를 할당받기까지의 시간

---

## 3. CPU 스케줄링 방식

### 비선점형 스케줄링 (Non-Preemptive Scheduling)

- 프로세스가 CPU를 할당받으면 종료 또는 I/O 요청 전까지 CPU를 반환하지 않음
- 대표 알고리즘:
    - FCFS (First-Come, First-Served)
    - SJF (Shortest Job First)

### 선점형 스케줄링 (Preemptive Scheduling)

- 실행 중인 프로세스보다 높은 우선순위의 프로세스가 도착하거나 특정 조건을 만족하면 CPU를 강제로 반환
- 대표 알고리즘:
    - Round Robin (RR)
    - Priority Scheduling
    - SRTF (Shortest Remaining Time First)

---

## 4. CPU 스케줄링 알고리즘

### 선입선출 (First-Come First-Served, FCFS)

- 유형: 비선점형
- 방식: 준비 큐에 도착한 순서대로 CPU를 할당
- 장점: 단순하고 공평한 방식
- 단점:
    - CPU 버스트가 긴 프로세스가 먼저 오면 전체 대기 시간 증가
    - I/O 바운드 프로세스의 지연 → 콘보이 효과 (Convoy Effect)

### 최단작업 우선 (Shortest Job First, SJF)

- 유형: 비선점형
- 방식: CPU 버스트 시간이 가장 짧은 프로세스에 우선 할당
- 장점: 평균 대기 시간이 가장 짧은 최적 알고리즘
- 단점: 실행 중인 프로세스보다 짧은 새 프로세스가 와도 CPU를 빼앗지 못함

### HRN (Highest Response Ratio Next)

- 유형: 비선점형 스케줄링
- 방식: (대기 시간 + 서비스 시간) ÷ 서비스 시간 = 응답률 계산 후, 응답률이 가장 높은 프로세스를 우선 실행
- 특징: 실행 시간이 짧은 프로세스를 선호하면서도 오래 기다린 프로세스의 우선순위를 높임
- 장점:
  - SJF보다 기아(Starvation) 현상을 완화
  - 대기 시간과 실행 시간을 동시에 고려하여 더 공정한 처리 가능
  - 에이징(Aging) 효과를 내재적으로 포함
- 단점:
  - 공평성 부족으로 일부 상황에서는 여전히 문제 발생
  - 응답률 계산을 위한 추가 연산 필요


###  SRTF (Shortest Remaining Time First)

- 유형: 선점형 (SJF의 선점형 버전)
- 방식: 남은 CPU 시간이 더 짧은 프로세스가 오면 현재 프로세스를 선점
- 장점: 평균 대기 시간이 가장 짧음
- 단점:
    - 기아 (Starvation) 발생 가능
    - 문맥 교환 횟수가 많아 오버헤드 증가

### 우선순위 스케줄링 (Priority Scheduling)

- 유형: 선점형 / 비선점형 (보통 선점형)
- 방식: 우선순위가 가장 높은 프로세스에게 CPU를 할당
- 장점: 특정 작업을 빠르게 처리 가능
- 단점:
    - 낮은 우선순위 프로세스가 무기한 대기 (기아 현상)
    - 해결 방법: 노화(Aging) 기법 사용

### 라운드 로빈 (Round Robin, RR)

- 유형: 선점형
- 방식: 각 프로세스에 동일한 타임 슬라이스를 부여하고 순환적으로 CPU 할당
- 장점:
    - 공평한 CPU 할당
    - 빠른 응답 시간 보장
- 단점:
    - 타임 슬라이스 설정이 중요
    - 너무 작으면 오버헤드 증가, 너무 크면 FCFS와 유사해짐


### 멀티레벨 큐 (Multi-level Queue)

- 유형: 주로 비선점형 (우선순위 큐 기반)
- 방식: 우선순위에 따라 여러 준비 큐 구성, 각 큐는 독립적인 스케줄링 적용
- 장점: 프로세스 특성에 따라 차별적 처리 가능
- 예시:
    - 전면 큐 (대화형): 라운드 로빈
    - 후면 큐 (계산 위주): FCFS

### 멀티레벨 피드백 큐 (Multi-level Feedback Queue)

- 유형: 선점형
- 방식: 프로세스의 실행 이력에 따라 우선순위를 동적으로 조정하며 큐 간 이동 허용
- 장점:
    - 기아 현상 완화
    - 다양한 프로세스에 유연하게 대응
- 특징:
    - CPU를 사용할수록 우선순위가 낮아짐 (하위 큐로 이동)
    - 필요에 따라 상위 큐로 이동 가능
    - 낮은 우선순위 큐일수록 긴 타임 슬라이스 사용

### 기타

- 콘보이 효과
  - 실행 시간이 긴 프로세스를 먼저 처리해 전체 시스템 효율이 떨어지는 현상
- 기아 현상
  - 낮은 우선순위의 프로세스가 계속 처리되지 못해 영원히 대기하는 문제
  - 이는 실행 시간뿐 아니라 모든 우선순위 기반 스케줄링에서 발생할 수 있다.
- Aging 기법
  - 정의: 오래 대기한 프로세스의 우선순위를 점차 높여 기아(Starvation) 현상을 방지하는 기법.
  - 목적: 우선순위가 낮아 실행되지 못하는 프로세스가 영원히 대기하지 않도록 보장.
  - 작동 방식: 대기 시간이 길어질수록 우선순위를 주기적으로 상승시킴.
  - 사용 예시: 운영체제의 프로세스 스케줄러, 디스크 스케줄링 등.

---

### 참고자료

[CPU 스캐쥴링](https://bnzn2426.tistory.com/65)