# 페이징

---

## 1. 페이징 기법

- 페이징 기법은 고정 분할 방식의 가상 메모리 관리 기법이다. 
- 메모리를 일정 크기로 나누어 페이지(Page)와 프레임(Frame) 단위로 관리한다.
  - 이 과정에서 가상 주소를 물리 주소로 변환하는 방법과 페이지 테이블(Page Table)을 통한 매핑 정보를 관리한다.

---

## 2. 페이징 기법의 구현

### 기본 개념

- 가상 메모리(Virtual Memory): 프로세스가 인식하는 주소 공간이며, 항상 0번지부터 시작한다.
- 물리 메모리(Physical Memory): 실제 컴퓨터의 RAM 주소 공간이다.
- 가상 주소 공간은 동일한 크기의 블록 단위로 분할되며, 이 블록을 페이지(Page)라고 한다.
- 물리 메모리도 같은 크기의 블록 단위로 나누며, 이를 프레임(Frame)이라 부른다.
- 페이지와 프레임은 크기가 동일하므로, 어떤 페이지든 어떤 프레임에 배치될 수 있다.

### 페이지 및 프레임 번호

- 각 페이지와 프레임은 0번부터 번호를 매긴다.
- 예를 들어 페이지 0은 가상 주소 0~9, 페이지 1은 10~19와 같이 구성된다.
- 프레임도 동일하게 구성된다. 프레임 0은 물리 주소 0~9, 프레임 1은 10~19처럼 관리된다.

### 페이지 테이블 (Page Table)

- 페이지 테이블은 프로세스의 가상 페이지 번호와 실제 프레임 번호를 매핑하는 테이블이다.
- 구성은 한 열(Column)로 되어 있으며, 각 페이지에 해당하는 프레임 번호가 순서대로 나열된다.
- 예: 페이지 0 → 프레임 2, 페이지 1 → 프레임 3, 페이지 3 → 프레임 1 등.
- 페이지가 물리 메모리에 없을 경우, 해당 항목은 `invalid`로 표시되며, 이는 해당 페이지가 현재 스왑 영역(디스크)에 있다는 의미다.

---

## 3. 페이징 기법의 주소 변환

### 주소 구조의 정의

- 가상 주소(Virtual Address, VA)는 `VA = <P, D>` 형식으로 표현된다.
    - `P`는 페이지 번호 (Page Number)
    - `D`는 해당 페이지 안에서의 거리, 즉 오프셋(Offset)
- 물리 주소(Physical Address, PA)는 `PA = <F, D>` 형식으로 표현된다.
    - `F`는 매핑된 프레임 번호 (Frame Number)
    - `D`는 동일한 오프셋 (가상 주소의 D 그대로 사용)

### 주소 변환 예시

#### 예시 1: 가상 주소 30번지를 읽을 때

- 가상 주소 30은 페이지 크기 10B 기준으로 페이지 3의 0번째 위치, 즉 `VA = <3, 0>`이다.
- 페이지 테이블에서 페이지 3 → 프레임 1임을 확인.
- 최종 물리 주소는 `PA = <1, 0>`, 즉 프레임 1의 0번째 위치.

#### 예시 2: 가상 주소 18번지에 값을 저장할 때

- 가상 주소 18은 페이지 1의 8번째 위치 → `VA = <1, 8>`.
- 페이지 테이블에서 페이지 1은 프레임 3에 위치함.
- 최종 물리 주소는 `PA = <3, 8>`.

---

## 4. 정형화된 주소 변환 공식

- 페이징 기법에서 가상 주소 → 물리 주소 변환은 다음 과정을 따른다
1. 가상 주소 VA = <P, D>를 분해
    - 페이지 번호 `P = ?VA / 페이지 크기?`
    - 오프셋 `D = VA % 페이지 크기`
2. 페이지 테이블 참조를 통해
    - 페이지 P가 매핑된 프레임 F를 찾음.
3. 물리 주소 PA 계산
    - `PA = (F × 프레임 크기) + D`

### 변환 예시 (공식 적용)

- 페이지 크기 = 10B
- 가상 주소 VA = 72
    - `P = ?72 / 10? = 7`, `D = 72 % 10 = 2` → `VA = <7, 2>`
    - 페이지 7 → 예를 들어 프레임 0이라고 가정하면, `PA = <0, 2>` → 물리 주소는 2번지

---

## 5. 주소 변환 실패 시 처리

- 페이지 테이블에 `invalid`로 표시된 항목은 현재 물리 메모리에 없는 페이지를 의미한다.
- 이 경우 페이지 부재(Page Fault)가 발생하고, 운영체제는 디스크의 스왑 영역에서 해당 페이지를 불러온 뒤 프레임에 적재한다.
- 이후, 페이지 테이블을 갱신하여 페이지에 해당하는 새로운 프레임 번호를 기록한다.

---

## 6. 페이지 테이블 관리

### 페이지 테이블의 필요성과 구조

- 시스템에는 다수의 프로세스가 존재하고, 각 프로세스마다 고유한 페이지 테이블이 하나씩 존재한다. 
- 프로세스는 메모리에 적재되어야 실행 가능하며, 적재 시 일부 페이지가 물리 메모리의 프레임에 올라간다. 
- 페이지 테이블은 해당 프로세스의 가상 주소를 물리 주소로 매핑하기 위해 사용된다.

### 예시: 다수 프로세스의 페이지 테이블

- 프로세스 A, B, C가 물리 메모리를 공유하고 있을 때:
  - A의 페이지 0은 프레임 1에, 
  - B의 페이지 0은 프레임 3에, 
  - C의 페이지 0은 프레임 0에 위치한다. 
- 메모리 관리자는 각 프로세스가 실행될 때 해당 프로세스의 페이지 테이블을 참조하여 주소 변환 작업을 수행한다.

### 페이지 테이블의 위치와 접근 속도
   
- 페이지 테이블은 운영체제 영역의 일부인 물리 메모리 내에 저장된다. 
- 메모리 관리자는 빠른 접근을 위해 페이지 테이블 기준 레지스터(Page Table Base Register, PTBR)를 사용한다. 
- PTBR은 각 프로세스의 제어 블록(PCB)에 존재하며, 페이지 테이블 시작 주소를 저장하고 있다.

### 페이지 테이블의 크기 문제
   
- 예시: 32bit 시스템에서 페이지 크기가 512B일 경우 
- 가상 주소 공간: 2³² = 4GB 
- 페이지 수 = 4GB / 512B = 약 8,388,608개 
- 각 페이지에 3바이트씩만 매핑 정보를 할당해도 페이지 테이블 크기는 약 24.11MB 
- 프로세스가 40개인 경우 총 페이지 테이블 크기는 약 1GB에 달할 수 있다. 
- 이는 전체 물리 메모리의 1/4에 해당하는 양이다.

### 메모리 부족 시의 처리

- 물리 메모리가 부족한 경우:
  - 프로세스의 일부 혹은 전체가 스왑 영역으로 이동될 수 있음 
  - 페이지 테이블 또한 전부 메모리에 상주하지 못하고 일부는 스왑 영역으로 옮겨짐 
- 이러한 상황을 고려하여 효율적인 페이지 테이블 관리 방식이 필요하다.

---

## 7. 페이지 테이블 매핑 방식

### 매핑 방식의 필요성

- 페이지 테이블 전체가 항상 메모리에 상주하지는 못할 수 있으므로, 페이지 테이블의 저장 위치와 접근 방식을 효율적으로 설계해야 한다. 
- 가상 주소를 물리 주소로 변환하는 과정에서의 성능 저하를 방지하기 위해 다양한 매핑 방식이 존재한다.

### 직접 매핑 (Direct Mapping)

#### 구조 및 원리

- 전체 페이지 테이블이 물리 메모리에 고정된 위치에 존재 
- 가상 주소는 다음과 같이 구성됨: 가상 주소 = (페이지 번호, 페이지 내 오프셋)
- 페이지 번호를 인덱스로 사용하여 페이지 테이블에 바로 접근 → 해당 페이지의 프레임 번호를 얻음 
- 물리 주소 = (프레임 번호, 오프셋)

#### 장점

- 접근 속도가 매우 빠름 (단순 인덱싱)
- 주소 변환 과정이 단순해서 하드웨어 구현이 용이함

#### 단점

- 페이지 테이블 크기가 가상 주소 공간 크기에 비례 → 매우 커질 수 있음 
- 전체 페이지 테이블을 물리 메모리에 항상 상주시켜야 하므로 공간 낭비가 심함

#### 사용 예

- 소형 시스템이나 임베디드 시스템 등, 메모리 사용이 예측 가능한 경우

### 연관 매핑 (Associative Mapping)
   
#### 구조 및 원리

- 페이지 테이블을 캐시처럼 연관 메모리에 저장함
- (페이지 번호, 프레임 번호) 쌍으로 저장 
- 가상 주소의 페이지 번호를 모든 항목과 비교해서 일치하는 항목을 찾음

#### 장점

- 매우 유연한 배치 가능 
- 어떤 페이지가 어떤 프레임에 위치해도 문제 없음 
- 페이지 테이블 크기가 작을 수 있음

#### 단점

- 비교 연산이 많아지므로 탐색 시간 증가 
- 빠른 탐색을 위해 전용 하드웨어(연관 메모리) 필요

#### 구현 방식

- CAM(Content Addressable Memory) 기반 연산 
- 주로 TLB(Translation Lookaside Buffer) 같은 캐시에 적용됨

### 집합-연관 매핑 (Set-Associative Mapping)

#### 구조 및 원리
   
- 전체 페이지 테이블을 여러 집합(set)으로 나눔 
- 각 집합 안에서는 연관 매핑 방식 적용 
- 페이지 번호 일부를 집합 번호, 나머지를 태그로 사용

#### 장점

- 직접 매핑보다 유연하고, 연관 매핑보다 빠름 
- 메모리 낭비를 줄이면서도 비교 항목 수를 제한하여 속도 확보

#### 단점

- 집합 크기를 잘못 정하면 성능 저하 발생 
- 구조가 복잡해지고, 메모리 배치 관리 필요

#### 사용 예

- TLB 설계에 자주 사용됨 (예: 4-way set associative TLB)

### 역매핑 (Inverted Page Table Mapping)

#### 구조 및 원리

- 페이지 번호를 인덱스로 삼는 기존 방식 대신, 프레임을 기준으로 매핑 
- 하나의 전역 테이블만 사용함 → 시스템 전체에서 유일 
- 각 엔트리는 다음 정보를 가짐:
  - 어떤 프로세스의 
  - 어떤 페이지가 
  - 해당 프레임에 매핑되어 있는가

#### 주소 변환 과정

- 가상 주소에서 (프로세스 ID, 페이지 번호)를 추출 
- 역 페이지 테이블에서 해당 페이지를 찾기 위해 전체 또는 해시 탐색 
- 매칭되는 항목이 있으면 그 프레임 번호를 물리 주소로 사용 
- 없으면 페이지 폴트 발생

#### 장점

- 페이지 테이블 크기가 작아짐 
  - 프레임 수만큼의 엔트리만 필요 (페이지 수에 비례 아님)
- 모든 프로세스를 위한 단일 테이블 관리 가능

#### 단점

- 주소 변환에 시간이 오래 걸림 (해시 탐색 또는 선형 탐색)
- 해시 충돌 처리 필요 
- 페이지 교체 시 테이블 동기화가 복잡함

#### 사용 예

- IBM PowerPC 계열 시스템 등에서 채택

---

## 8. 테이블 매핑 방식 비교

| 구분           | 직접 매핑       | 연관 매핑       | 집합-연관 매핑     | 역매핑              |
|----------------|------------------|------------------|----------------------|----------------------|
| 페이지 테이블 크기 | 매우 큼           | 작음              | 중간                  | 작음 (프레임 수만큼)   |
| 주소 변환 속도   | 매우 빠름         | 느림              | 빠름                  | 느림                 |
| 유연성          | 낮음             | 높음              | 중간                  | 높음                 |
| 구현 난이도      | 낮음             | 높음 (하드웨어 필요) | 중간                  | 높음                 |
| 대표 적용       | 단순 시스템       | 고속 캐시 (TLB)    | 고속 TLB              | 시스템 전체 단일 테이블 |

---

### 참고자료

[쉽게 배우는 운영체제](https://product.kyobobook.co.kr/detail/S000001743685)