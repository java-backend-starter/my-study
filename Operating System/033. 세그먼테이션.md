# 세그먼테이션

---

## 1. 세그먼테이션 기법

- 세그먼테이션(segmentation) 기법은 가상 메모리를 가변 크기의 논리적 단위(세그먼트)로 나누고, 이를 물리 메모리에 가변적으로 할당하는 방식의 메모리 관리 기법이다.

---

## 2. 세그먼테이션 기법의 구조 및 구현

### 개념

- 세그먼트(Segment): 코드, 데이터, 스택 등 논리적으로 구분된 메모리 블록
- 가상 주소(Virtual Address)는 다음과 같이 구성된다:  
  VA = <S, D>
    - S: 세그먼트 번호 (Segment Number)
    - D: 세그먼트 내 오프셋(Offset), 즉 세그먼트 시작 주소로부터의 거리

### 세그먼테이션 테이블(Segmentation Table)

- 각 프로세스는 하나의 세그먼테이션 테이블을 가진다.
- 세그먼트마다 다음 정보를 저장한다:
    - limit: 세그먼트의 최대 크기 (접근 가능한 범위)
    - address: 세그먼트의 물리 메모리 시작 주소
- 페이징 기법과는 달리, 세그먼트 크기가 일정하지 않기 때문에 limit 정보가 반드시 필요하다.

### 주소 변환 방식

- 가상 주소 <S, D>를 물리 주소로 변환하는 과정:
  1. 세그먼트 번호 S를 통해 세그먼테이션 테이블에서 해당 항목을 찾는다.
  2. 해당 세그먼트의 limit을 참조해 D가 허용 범위인지 확인한다.
      - D > limit인 경우 → 트랩(trap) 발생 (메모리 오류)
  3. 유효한 경우: address(S) + D = 물리 주소(PA)
- 예시:
  - 가상 주소: <0, 32>
  - 세그먼트 0의 시작 주소(address): 120
  - 세그먼트 0의 limit: 280
  - 계산: 120 + 32 = 152 → 물리 주소 152번지 접근

---

## 3. 메모리 보호 및 트랩

### 메모리 보호

- limit 값은 세그먼트의 최대 허용 범위를 나타낸다.
- 세그먼트 경계를 벗어난 접근은 허용되지 않는다.
- 시스템은 접근 시 항상 D ≤ limit 여부를 체크한다.

### 트랩 (Trap)

- 트랩: 사용자의 의도치 않은 잘못된 작업으로 발생한 인터럽트
- 대표 예시:
    - 세그먼트의 범위를 넘는 주소 접근
    - 0으로 나누기
- 트랩 발생 시 운영체제는 해당 프로세스를 종료시키며, 보통 Segmentation Fault 메시지를 출력한다.

### 시그널 (Signal)

- 시그널: 사용자가 의도적으로 발생시키는 인터럽트
- 예시: Ctrl + C를 눌러 프로세스를 중지
- 외부 인터럽트의 일종

---

## 4. 스왑 영역과 세그먼트 상태

- 물리 메모리가 부족하면, 일부 세그먼트를 디스크의 스왑 영역으로 이동한다.
- 해당 세그먼트는 세그먼테이션 테이블의 address 필드에 I (invalid)로 표시된다.
- 이 경우 해당 세그먼트에 접근 시, 운영체제가 세그먼트를 다시 물리 메모리로 불러온다 (Swap-in).

---

## 5. 장단점 비교

| 구분 | 내용 |
|------|------|
| 장점 | - 논리적 구조를 반영한 메모리 분할 (코드/데이터/스택 분리) <br> - 페이지 단위가 아니므로 테이블이 작고 단순 |
| 단점 | - 외부 단편화 발생 가능 <br> - 메모리 관리가 복잡함 (동적 할당, 스왑 등 처리) |

---

## 6. 페이징과의 비교 요약

| 항목 | 세그먼테이션 | 페이징 |
|------|---------------|--------|
| 단위 | 논리적 세그먼트 | 고정 크기 페이지 |
| 주소 형식 | <세그먼트 번호, 오프셋> | <페이지 번호, 오프셋> |
| 테이블 크기 | 작음 (프로세스당 몇 개) | 큼 (페이지 수만큼) |
| 단편화 | 외부 단편화 발생 | 내부 단편화 발생 |
| 보호 방식 | limit 값으로 경계 보호 | 페이지 단위로 보호 |

---

## 7. 세그먼테이션-페이징 혼용 기법

- 페이징 기법은 고정된 크기의 물리 메모리 블록(프레임)에 가상 메모리 블록(페이지)을 매핑하는 방식
  - 메모리 관리가 효율적이지만 페이지 테이블 크기가 커진다는 단점이 있음.  
- 세그먼테이션 기법은 의미 단위로 메모리를 나누어 관리하여 유연성이 높고 테이블이 작지만, 외부 단편화가 발생함.  
- 이 두 방식의 장점을 조합한 방식이 세그먼테이션-페이징 혼용 기법이다.

---

## 8. 메모리 접근 권한

- 메모리 접근 권한은 다음 4가지로 분류됨:
  - 읽기 (Read)
  - 쓰기 (Write)
  - 실행 (Execute)
  - 추가 (Append): 기존 데이터의 끝에 덧붙이는 권한 (쓰기 권한 포함 전제)

### 접근 권한 조합

- 이론상 4가지 권한의 조합으로 2⁴ = 16가지 가능
- 그러나 ‘추가’ 권한은 쓰기 권한이 반드시 포함되어야 하므로 실질적으로는 8가지 조합만 사용
- 그 중 읽기 없이 쓰기만 하는 모드(2, 3)는 실제로 거의 사용되지 않음

### 영역별 접근 권한

- 코드 영역: 수정하지 않으므로 읽기와 실행만 허용됨
- 데이터 영역
    - 일반 변수: 읽기 및 쓰기 가능
    - 상수: 읽기만 가능
- 메모리 접근 권한은 주소 변환이 발생할 때마다 검사되며, 권한이 없는 접근 시 ‘트랩’ 발생.

---

## 9. 혼용 기법의 도입

### 문제점: 순수 페이징 방식

- 페이지마다 권한 비트를 저장하면 테이블이 커짐
- 많은 페이지가 동일한 권한을 공유해도 각 페이지마다 비트를 중복 저장해야 함 → 비효율적

### 해결책: 세그먼트 기반 권한 관리

- 관련된 페이지를 세그먼트로 묶고, 공통 권한 정보를 세그먼트 단위로 관리
- 세그먼테이션 테이블은 각 세그먼트의 시작 주소, 크기, 접근 권한, 연결된 페이지 테이블 주소를 저장
- 이렇게 하면 권한 비트, 소유 정보 등의 중복을 줄이고 페이지 테이블의 크기를 작게 유지할 수 있음.

---

## 10. 혼용 기법에서의 주소 변환

### 가상 주소 구성

- VA = <S, P, D>
    - S: 세그먼트 번호
    - P: 세그먼트 내 페이지 번호
    - D: 페이지 내 오프셋

### 주소 변환 단계

1. 사용자가 요청한 주소를 세그먼트 번호(S), 페이지 번호(P), 오프셋(D)로 나눔
2. 세그먼트 테이블의 S번 항목을 참조:
    - 접근 범위 초과 여부 검사 (유효성 확인)
    - 접근 권한 검사 (읽기, 쓰기 등)
    - 이상 없으면 페이지 테이블의 시작 주소를 얻음
3. 페이지 테이블에서 페이지 번호 P에 해당하는 항목을 조회:
    - 해당 페이지가 메모리에 존재하는지 확인
    - 존재하지 않으면 스왑 영역에서 해당 페이지를 불러옴
4. 프레임의 시작 주소 + 오프셋 D → 최종 물리 주소
5. 물리 주소에 접근하여 데이터 읽기/쓰기 수행

### 요약 흐름

- 가상 주소 (<S, P, D>) → 세그먼트 테이블 → 페이지 테이블 → 물리 주소 변환 → 메모리 접근

---

## 11. 장점

- 공통 권한 및 속성 정보를 세그먼트 단위로 묶어 관리함으로써 페이지 테이블의 크기를 줄임
- 사용자 관점에서는 논리적인 세그먼트 사용, 운영체제 관점에서는 물리적 페이지 단위로 관리 → 효율성과 유연성 동시 확보
- 유닉스 시스템처럼 사용자/그룹/기타의 권한 정보도 세그먼트 테이블에서 관리 가능

---

## 12. 실제 활용

- 대부분의 현대 운영체제는 이 혼합 기법을 채택하여 가상 메모리를 효율적으로 관리하고 있음.  
- 세그먼트 기반의 유효성 검사와 권한 관리를 통해 보안과 안정성을 보장하면서도, 페이징의 메모리 할당 효율성을 함께 누릴 수 있음.

---

### 참고자료

[쉽게 배우는 운영체제](https://product.kyobobook.co.kr/detail/S000001743685)