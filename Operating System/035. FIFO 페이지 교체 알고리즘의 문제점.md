# FIFO 페이지 교체 알고리즘의 문제점

---

## 1. 개요

- FIFO 페이지 교체 알고리즘은 메모리에서 가장 오래된 페이지부터 차례대로 교체하는 방식이다. 
- 이 알고리즘은 큐(queue) 자료 구조를 활용하여 페이지의 순서를 관리하고, 가장 먼저 들어온 페이지를 먼저 교체하는 방식으로 동작한다.


### 동작 원리

- FIFO 알고리즘의 핵심 원리는 선입선출(First In, First Out)이다. 
- 페이지가 메모리에 들어온 순서대로 관리되며, 메모리가 꽉 차면 가장 먼저 들어온 페이지부터 교체된다.
  - 페이지 부재(Page Fault): 요청한 페이지가 메모리에 없을 경우 페이지 부재가 발생하고, 가장 오래된 페이지를 스왑 영역으로 보내고 새로운 페이지를 메모리에 넣습니다.
  - 페이지 교체: 메모리에 페이지가 꽉 차면, 큐에서 가장 오래된 페이지를 제거하고 새로운 페이지를 큐에 추가합니다.

### 구현 방법

- FIFO는 큐 자료 구조를 사용하여 구현된다.
- 큐의 맨 앞에 있는 페이지는 가장 오래된 페이지이며, 맨 뒤에 새로운 페이지가 추가된다.
- 메모리에 공간이 부족하면 큐의 맨 앞에 있는 페이지를 제거하고 새로운 페이지를 큐의 맨 뒤에 삽입한다.

### 동작 예시

- 다음은 FIFO 페이지 교체 알고리즘의 동작 예시입니다:
  - 예를 들어, 메모리가 3개의 페이지만을 저장할 수 있고, 페이지 접근 순서가 A, B, C, A, D, B, A라고 가정합니다.
  - 1번: 페이지 A가 메모리에 들어온다.
  - 2번: 페이지 B가 메모리에 들어온다.
  - 3번: 페이지 C가 메모리에 들어온다. 
  - 4번: 페이지 A를 다시 요청합니다. A는 메모리에 있으므로 페이지 부재가 발생하지 않습니다.
  - 5번: 페이지 D가 들어오게 되면, FIFO 규칙에 따라 가장 오래된 페이지 A가 스왑 영역으로 이동하고, D가 메모리에 들어옵니다.
  - 6번: 페이지 B를 요청하면 메모리에 있으므로 성공(S)입니다.
  - 7번: 페이지 A를 다시 요청하면, A는 이미 스왑 영역에 있기 때문에 페이지 부재가 발생하고, A가 메모리에 다시 로드됩니다.

### FIFO의 동작 구조

- 페이지 부재: 원하는 페이지가 메모리에 없을 때 발생. 예시에서 페이지 D가 들어올 때 A가 교체됩니다.
- 성공(Success): 페이지가 이미 메모리에 있을 때 발생. 예시에서 페이지 B는 성공(S)으로 표시됩니다.

---

## 2. FIFO의 문제점

- FIFO는 구현이 간단하지만 여러 가지 성능상의 문제를 야기할 수 있습니다.
1. 자주 사용되는 페이지가 교체될 수 있음:
   - FIFO는 페이지의 접근 순서만을 고려하여 교체하기 때문에, 오래된 페이지가 항상 교체된다. 
   - 그러나 실제로는 오래된 페이지가 자주 사용되지 않는 경우가 많고, 최근에 들어온 페이지 중 자주 사용되는 페이지가 있을 수 있다. 
   - 이 경우, 자주 사용되는 페이지가 교체되어 성능 저하를 초래할 수 있다.
2. 시간 지역성의 부재:
   - FIFO는 시간 지역성(locality of reference)을 고려하지 않기 때문에, 자주 참조되는 페이지가 이미 스왑 영역으로 이동하여 성능이 낮아질 수 있다. 
   - 예를 들어, 최근에 들어온 페이지가 자주 사용되면 해당 페이지는 교체될 가능성이 높아지기 때문에 효율적인 페이지 관리가 되지 않는다.
3. Belady의 안모니:
   - FIFO 알고리즘은 Belady's Anomaly라는 현상을 보일 수 있다. 
   - 이는 페이지 수가 늘어나면 페이지 부재율이 오히려 증가하는 현상으로, FIFO 알고리즘에서는 메모리 크기가 증가할수록 성능이 떨어질 수 있다는 점에서 문제가 된다.

---

## 3. FIFO 알고리즘 개선 방법

- FIFO의 단점들을 보완하기 위해 2차 기회(Second Chance) 페이지 교체 알고리즘이 등장한다. 

### 2차 기회 페이지 교체 알고리즘 (Second Chance Algorithm)

- FIFO와 비슷하지만, 페이지에 접근할 때마다 성공한 페이지는 큐의 맨 뒤로 이동하여 교체되지 않도록 기회를 한 번 더 제공한다. 
- 참조 비트를 사용해 페이지의 접근 여부를 추적하고, 참조 비트가 1인 페이지는 교체하지 않고 뒤로 보내는 방식이다. 
- 2차 기회 알고리즘은 FIFO보다 성능이 조금 더 나으며, LRU, LFU, NUR보다 성능이 낮다.
- 단점: 큐를 유지하는 비용이 높고, 성공한 페이지를 큐의 중간에서 뒤로 이동시키는 추가 작업이 필요하다.

### 시계 알고리즘 (Clock Algorithm)

- 2차 기회 알고리즘과 유사하지만, 큐 대신 원형 큐를 사용한다. 
- 대상 포인터를 사용하여 페이지를 순차적으로 검사하고, 참조 비트가 1인 페이지는 건너뛰며, 0인 페이지만 교체한다.

#### 동작

- 페이지가 메모리에 올라오면 대상 포인터가 해당 페이지를 가리킨다. 
- 페이지에 접근하여 참조 비트가 1이면 건너뛰고, 0이면 해당 페이지를 교체한다. 
- 포인터는 원형 큐처럼 한 바퀴를 돌며, 참조 비트가 1인 페이지는 다시 0으로 초기화된다. 
- 장점: 추가적인 메모리 공간이 적고, NUR 알고리즘보다 간단하지만 계산량이 많아 복잡하다.

### 비교 요약

- 2차 기회 알고리즘: FIFO를 개선하여 성능을 조금 더 향상시키며, 큐를 뒤로 이동시키는 추가 작업이 필요. 
- 시계 알고리즘: 2차 기회 알고리즘과 비슷하나 원형 큐와 대상 포인터를 사용하여 효율적으로 페이지를 교체하지만 알고리즘이 복잡하다.

---

## 4. FIFO 알고리즘 장단점

### 장점:

- 구현의 용이성: 큐 구조를 사용하여 간단하게 구현할 수 있습니다.
- 직관적 이해: "먼저 들어온 페이지부터 교체"라는 직관적인 규칙을 따르기 때문에 이해하기 쉽습니다.

### 단점:

- 성능 저하: 자주 사용되는 페이지가 교체될 수 있어 성능이 떨어질 수 있습니다.
- 효율성 부족: 메모리의 시간 지역성을 고려하지 않기 때문에 자주 참조되는 페이지가 불필요하게 교체될 수 있습니다.

---

### 참고자료

[쉽게 배우는 운영체제](https://product.kyobobook.co.kr/detail/S000001743685)