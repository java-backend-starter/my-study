# CQRS

---

## 1. CQRS (Command Query Responsibility Segregation) 패턴

- CQRS는 시스템의 명령(Command)과 조회(Query) 책임을 분리하여 성능, 확장성, 보안성을 향상시키는 아키텍처 패턴이다.
- 이는 특히 복잡한 도메인 모델이나 읽기/쓰기 비율이 불균형한 시스템에서 유용하게 적용된다.

---

## 2. CQRS 패턴의 핵심 개념

- CQRS는 시스템의 쓰기 작업과 읽기 작업을 별도의 모델로 분리한다.
  - 명령(Command) 모델: 데이터의 생성, 수정, 삭제 등 상태 변경을 담당힌다.
  - 조회(Query) 모델: 데이터의 검색 및 조회를 담당하며, 상태 변경을 하지 않는다.
- 이러한 분리를 통해 각 모델을 독립적으로 최적화할 수 있으며, 시스템의 복잡성을 줄이고 유지보수를 용이하게 한다.

---

## 3. CQRS의 장점

1. 독립적인 확장성: 읽기와 쓰기 작업을 별도로 확장할 수 있어, 시스템의 부하를 효율적으로 관리할 수 있다.
2. 최적화된 데이터 스키마: 읽기와 쓰기 모델에 각각 최적화된 데이터 구조를 사용할 수 있다.
3. 보안 강화: 읽기와 쓰기 작업을 분리함으로써, 각 작업에 대한 접근 제어를 강화할 수 있다.
4. 관심사의 분리: 비즈니스 로직과 데이터 접근 로직을 분리하여 코드의 가독성과 유지보수성을 향상시킨다.
5. 단순한 쿼리: 조회 모델은 복잡한 조인 없이도 필요한 데이터를 제공할 수 있어, 쿼리의 복잡성을 줄인다.

---

## 4. CQRS의 단점 및 고려사항

1. 복잡성 증가: 시스템 구조가 복잡해져 초기 개발 비용이 증가할 수 있다.
2. 결과적 일관성: 읽기 모델이 쓰기 모델의 변경을 실시간으로 반영하지 않을 수 있어, 일관성 문제가 발생할 수 있다.
3. 메시징 시스템 필요: 명령과 조회 모델 간의 동기화를 위해 메시징 시스템이 필요할 수 있다.
4. 테스트 및 디버깅의 어려움: 분리된 모델로 인해 전체 시스템의 테스트 및 디버깅이 복잡해질 수 있다.

---

## 5. CQRS 적용이 적합한 상황

- 읽기 작업이 쓰기 작업보다 훨씬 많은 경우
- 복잡한 비즈니스 로직이 존재하는 경우
- 여러 팀이 병렬로 개발을 진행해야 하는 경우
- 시스템이 점진적으로 진화하거나 다양한 버전의 모델을 포함해야 하는 경우
- 이벤트 소싱과 결합하여 다른 시스템과의 통합이 필요한 경우

---

## 6. CQRS 적용이 부적합한 상황

- 도메인이나 비즈니스 로직이 단순한 경우
- 간단한 CRUD 스타일의 애플리케이션인 경우
- 시스템 복잡성 증가에 따른 이점이 크지 않은 경우

---

## 7. 결론

- CQRS 패턴은 시스템의 요구사항과 복잡성에 따라 신중하게 적용해야 한다.  
- 적절한 상황에서 활용하면 시스템의 성능과 유지보수성을 크게 향상시킬 수 있다.


---

### 참고자료

[CQRS](https://code-overflow.tistory.com/entry/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-CQRS-%ED%8C%A8%ED%84%B4Command-Query-Responsibility-Segregation-Pattern)