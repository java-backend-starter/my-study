# 옵저버 패턴

---

## 1. 개요

- 옵저버 패턴은 '한 객체의 상태 변화가 있을 때, 그 객체에 의존하는 다른 객체들에게 자동으로 알림을 보내는 패턴'이다. 
- 일대다(one-to-many) 의존성을 가지며, 주로 분산 이벤트 핸들링 시스템에 사용된다. 
- 예를 들어, 유튜브 채널이 발행자(Subject) 역할을 하고, 구독자들이 관찰자(Observer) 역할을 한다.

---

## 2. 옵저버 패턴 흐름

1. 관찰 대상자(Subject)는 여러 관찰자(Observer)를 등록하여 관리합니다. 
2. Subject의 상태가 변경되면, 등록된 모든 Observer에게 알림을 보냅니다. 
3. Observer는 알림을 받아 상태를 갱신하거나 적절한 처리를 합니다. 
4. Observer는 언제든지 Subject의 관찰 대상에서 추가되거나 제거될 수 있습니다.

--- 

## 3. 옵저버 패턴 특징

### 사용 시기

- 한정된 시간 또는 특정 케이스에서 다른 객체를 관찰해야 하는 경우 
  - 예 : 시간이 특정한 이벤트가 발생할 때만 관찰, 특정 조건에서만 다른 객체를 추적할 필요가 있을 때 
- 대상 객체의 상태가 변경될 때마다 다른 객체의 동작을 트리거해야 할 때 
  - 예 : 사용자 인터페이스에서 사용자가 버튼을 클릭했을 때 그에 따른 동작을 트리거하는 경우
- 한 객체의 상태가 변경되면 다른 객체도 변경해야 할 때, 그런데 어떤 객체들이 변경될지 몰라도 될 때 
  - 객체 간의 상호작용을 관리해야 하지만, 변경될 객체를 명시적으로 알 필요가 없을 때 유용하다.
- MVC 패턴에서 Model과 View의 관계 
  - MVC 구조에서 Model은 Subject 역할을, View는 Observer 역할을 합니다. 
  - 하나의 Model에 여러 View가 연결되어 변화를 감지하고 표시하는 구조

### 장점

- 상태 변경을 주기적으로 조회하지 않고 자동으로 감지 
  - 발행자(Subject)의 상태가 변경될 때, 자동으로 알림이 전파되므로 주기적으로 상태를 체크할 필요가 없다. 
- 개방-폐쇄 원칙(OCP) 준수 
  - 발행자의 코드를 변경하지 않고도 새로운 구독자(Observer)를 추가할 수 있어 소프트웨어 설계에서 개방-폐쇄 원칙을 준수한다. 
- 런타임 시점에서 발행자와 구독 알림 관계 맺기 
  - 프로그램 실행 중에 발행자와 구독자 간의 관계를 설정할 수 있다. 
- 느슨한 결합 유지 
  - Subject와 Observer 간의 관계를 느슨하게 유지하여, 각 객체가 독립적으로 동작할 수 있다.

### 단점

- 알림 순서를 제어할 수 없음 
  - 옵저버들이 알림을 받는 순서를 제어할 수 없으며, 무작위 순서로 알림을 받게 된다.
- 하드 코딩으로 구현 시 복잡도 증가 
  - 하드 코딩으로 옵저버를 구현할 경우 코드의 복잡성과 결합도가 높아지며, 유지보수가 어려워질 수 있다.
- 구조 및 동작 복잡성 증가 
  - 옵저버 패턴을 자주 사용하면 코드의 구조와 동작을 이해하기 어려워져 코드의 복잡도가 증가할 수 있다.
- 메모리 누수 가능성 
  - 옵저버가 등록된 후 해지되지 않으면 메모리 누수가 발생할 수 있다.

---

## 4. 실무에서 찾을 수 있는 Observer 패턴 (자바 내장 옵저버 객체)

- 자바는 옵저버 패턴을 쉽게 사용할 수 있도록 내장된 객체들을 제공한다.
- 자바의 java.util.Observable 클래스와 java.util.Observer 인터페이스를 통해 옵저버 패턴을 직접 구현하지 않고도 간단하게 사용할 수 있다.

### 자바 내장 옵저버 객체

#### java.util.Observer 

- 이 인터페이스를 구현한 클래스는 옵저버 역할을 한다. 
- 옵저버 클래스는 update() 추상 메서드를 구현하여 발행자(Observable)로부터 데이터를 수신하게 된다.
- update(Observable o, Object arg) 메서드
  - 발행자(Observable)로부터 새로운 데이터를 수신하고 이를 갱신하는 역할을 한다.

#### java.util.Observable 

- 이 클래스는 옵저버들을 관리하는 발행자 역할을 하며, 새로운 데이터가 발생할 때 등록된 옵저버들에게 데이터를 전달한다. 
- Observable 클래스는 Vector 컬렉션을 통해 옵저버들을 관리한다. 
- 이 클래스는 스레드 안전(Thread-Safe) 하도록 동기화(Synchronized)가 적용되어 있다.
- 주요 메서드 
  - addObserver(Observer o): 옵저버를 옵저버 리스트에 추가한다. 
  - notifyObservers(): 새로운 데이터가 들어오면 등록된 모든 옵저버에게 알림을 보낸다. 
  - deleteObservers(): 등록된 모든 옵저버를 제거한다. 
  - setChanged()
    - 새로운 데이터가 들어오면 changed 값을 true로 설정하여 데이터 변경을 알린다.
    - changed가 true일 때만 옵저버에게 데이터가 전달된다. 
  - clearChanged(): changed 값을 false로 설정하여 발행을 멈춘다. 
  - hasChanged(): 현재 changed의 값을 반환한다. 
  - countObservers(): 현재 등록된 옵저버의 수를 반환한다.

### 참고자료

[옵저버 패턴](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%98%B5%EC%A0%80%EB%B2%84Observer-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)