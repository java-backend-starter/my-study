# SOLID

---

## 0. SOLID 원칙 

- 좋은 객체지향의 설계의 5가지 원칙
- SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존 역전 원칙)의 앞글자를 따서 만들어졌다
- SOLID 원칙을 철저히 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다

---

## 1. 단일 책임 원칙 (SRP, Single Responsibility Principle)

- 하나의 클래스는 단 하나의 책임만 가져야 한다는 원칙
- 즉, 클래스는 오직 하나의 이유로만 변경되어야 하며, 여러 가지 책임을 가질 경우 변경이 발생할 때마다 여러 부분에 영향을 미칠 수 있기 때문에 설계가 어려워진다

### 실제 예시

- 예를 들어, 만약 한 클래스가 사용자 정보를 처리하고, 그 정보를 파일에 저장하는 역할을 동시에 한다면, 그 클래스는 두 가지 책임을 진다 
- 이럴 경우 사용자 정보 처리와 저장 방식이 변경될 때 각각 별도의 수정이 필요할 수 있다. 
- 이러한 문제를 피하려면, 파일 저장 관련 코드를 별도의 클래스로 분리해야 한다.

---

## 2. 개방-폐쇄 원칙 (OCP, Open-Closed Principle)

- "소프트웨어 엔티티는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 원칙 
- 즉, 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 함

### 실제 예시

- 예를 들어, 기본적으로 결제 시스템을 구현했다고 할 때, 나중에 새로운 결제 방식을 추가하고자 한다면 기존 코드에 수정 없이 새로운 결제 방식을 추가할 수 있어야 한다
- 이를 위해 인터페이스나 추상 클래스 등을 사용하여 확장할 수 있는 구조로 설계

---

## 3. 리스코프 치환 원칙 (LSP, Liskov Substitution Principle)

- 하위 클래스는 상위 클래스에서 예상한 대로 동작할 수 있어야 한다는 원칙
- 즉, 하위 클래스는 상위 클래스로 대체할 수 있어야 하며, 그 대체로 인해 프로그램의 동작이 달라져서는 안된다.

### 실제 예시

- 예를 들어, `Animal`이라는 클래스가 있고 `Dog`와 `Cat`이라는 하위 클래스가 있다고 할 때, `Animal` 타입을 사용해야 하는 코드에 `Dog`나 `Cat`을 넣었을 때 문제가 발생하지 않도록 해야 한다. 
- 하위 클래스가 상위 클래스의 계약을 이행해야 한다는 것이다.

---

## 4. 인터페이스 분리 원칙 (ISP, Interface Segregation Principle)

- 클라이언트는 자신이 사용하지 않는 메서드에 의존해서는 안 된다는 원칙
- 즉, 인터페이스는 너무 많은 메서드를 포함하지 않아야 하며, 필요한 메서드만 제공해야 한다.

### 실제 예시

- 예를 들어, `Printer`라는 인터페이스가 있고 이 인터페이스가 `print()`와 `scan()` 메서드를 포함한다고 가정한다. 
- 그러나 만약 어떤 클래스가 `Printer` 인터페이스를 구현하면서 `scan()` 메서드는 사용하지 않으면, 그 클래스는 불필요한 메서드에 의존하게 된다. 
- 이때는 `Scanner`와 `Printer`를 별도로 분리하여 각 클래스가 필요로 하는 인터페이스만 상속받게 해야 한다.

---

## 5. 의존 역전 원칙 (DIP, Dependency Inversion Principle)

- 고수준 모듈은 저수준 모듈에 의존하면 안 되며, 두 모듈 모두 추상화에 의존해야 한다는 원칙
- 또한, 추상화된 의존 관계를 통해 코드가 좀 더 유연하고 변경에 강하게 만들어야 한다.

### 실제 예시

- 예를 들어, `OrderService`라는 고수준 모듈이 `DatabaseService`라는 저수준 모듈에 의존한다고 가정한다
- 이때 `OrderService`가 직접 `DatabaseService`에 의존하면, 데이터베이스 구현 방식이 바뀔 때마다 `OrderService`도 수정해야 한다. 
- 이를 해결하기 위해, `OrderService`는 `DatabaseService`를 직접 의존하는 대신 `DatabaseService`가 구현한 인터페이스를 의존하도록 설계해야 한다.

---

## 6. SOLID 원칙의 실무 적용

### SRP (단일 책임 원칙)

- 각 클래스는 하나의 책임을 가져야 하며, 이를 통해 변경에 대한 영향을 최소화하고, 코드가 더 읽기 쉽고 유지보수하기 쉬워집니다.

### OCP (개방-폐쇄 원칙)

- 이 원칙을 준수하면 소프트웨어의 확장성이 높아지고, 기존 코드를 변경하지 않으면서도 새로운 기능을 쉽게 추가할 수 있게 됩니다.

### LSP (리스코프 치환 원칙)

- 클래스의 상속 관계에서 하위 클래스는 언제든지 상위 클래스를 대체할 수 있어야 하므로, 이 원칙을 지키면 코드가 더 일관성 있고 예측 가능해집니다.

### ISP (인터페이스 분리 원칙)

- 클라이언트가 필요 없는 메서드까지 구현하게 되는 상황을 방지할 수 있으며, 보다 세밀한 분리된 인터페이스를 통해 코드의 유연성을 높일 수 있습니다.

### DIP (의존 역전 원칙)

- 추상화된 의존 관계를 유지하면 코드가 변화에 강해지며, 객체의 구현 방식 변경에 유연하게 대응할 수 있습니다.

---

## 7. SOLID 원칙의 상호 관계

- SRP와 ISP: 둘 다 클래스를 잘게 나누어 응집도를 높이고, 변경에 유연한 구조를 만드는 데 도움이 된다.
- LSP와 DIP: LSP는 다형성을 전제로 하고, DIP는 고수준 모듈과 저수준 모듈 간의 의존 관계를 추상화하여 OCP를 지원한다.

---

## 8. 스프링 프레임워크에서의 SOLID 적용

- 스프링에서는 DI(Dependency Injection)와 AOP(Aspect-Oriented Programming)를 사용하여 SOLID 원칙을 보다 쉽게 적용할 수 있다. 
- 예를 들어, 의존성 주입(DI)을 사용하여 DIP를 따르고, 서비스와 DAO를 분리하여 SRP를 적용할 수 있다.

---

### 참고자료

[SOLID](https://velog.io/@pp8817/SOLID-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99)